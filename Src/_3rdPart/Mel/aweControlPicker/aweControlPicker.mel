/*------------------------------------------------------------------------// SCRIPT OVERVIEW//------------------------------------------------------------------------	aweControlPicker.mel	Creates a GUI for adding quick-selection buttons for arbitrary 	selection sets, i.e. a GUI Picker	– version			1.0.4	– modified			01/2014	– author			"Awesome" A.D. / awesome@nyro.de	– source			http://nyro.de/scripts/aweControlPicker	– requires			Maya 2011+//------------------------------------------------------------------------// FEATURES//------------------------------------------------------------------------	 – Create GUI Pickers for arbitrary selection sets	 – Clean, minimalized and customizable interface	 – Freely edit position and appearance of Pickers	 – Organize Pickers into Tabs	 – Pickers can select and also set keys on objects	 – Pickers change functionality when shift, ctrl and alt modifiers are used	 – GUI Window is dockable, remembers size and position between sessions	 – Automated –albeit limited– alternate Prefix matching (Prefix, Hierarchy, Namespace)	 – Stores Pickers with scene	 – Works automatically with imported and referenced scenes (that contain Pickers)	 – Unique MarkingMenu for all Pickers in Viewport, Graph Editor and other panels	 – Save and Load Picker GUI for easy transfer and sharing	 – Written entirely in MEL for easy modification and future-proofing//------------------------------------------------------------------------// CHANGELOG [1.0.4]//------------------------------------------------------------------------	- Fixed:	A bug caused Maya to crash when script was executed on OSX. This has been fixed.//------------------------------------------------------------------------// HOTFIX [1.0.3.5]//------------------------------------------------------------------------	- Fixed:	Renaming a tab to an empty string caused Maya to crash. This has been fixed.	- Fixed:	The fileDialog command in Maya 2013 has been subtley changed, causing the 'Save' and				'Load' dialogs to not properly recognize the .cpf file extension. This has been fixed.	//------------------------------------------------------------------------// CHANGELOG [1.0.2] >> [1.0.3]//------------------------------------------------------------------------	- Fixed:	The implementation of a sceneEvent that doesn't exist in versions prior to Maya 2012				caused an error for users on Maya 2011. Those users must now manually trigger the Re-				Initialize command after importing or referencing scenes with Pickers.	- Added:	There is now a setting to define how the 'Set Key' function behaves when ctrl-clicking				a Picker (Key all objects, Key animated objects, Key animated channels only)	- Update:	Rewrote the CPClick command (formerly CPSelect) to account for the added option				described above and restructured the code in the process.	- Update:	Made a maintainence pass on the code, cleaning and streamlining the procedure comments				(the description now also informs of functions each procedure depends on)	- Fixed:	The Marking Menu implementation had a bug that caused the wrong Pickers to be displayed 				and/or the wrong objects to be selected under certain tab configurations.//------------------------------------------------------------------------// TO DO//------------------------------------------------------------------------	- Investigate why UI state isn't remembered in Maya 2011 (OSX?)//------------------------------------------------------------------------// CODE STRUCTURE//------------------------------------------------------------------------	##	SETTINGS		{ ... }	##	LOCAL PROCS		{ ... }	##	GLOBAL PROCS		{ ... }	##	CALLBACKS		{ ... }//------------------------------------------------------------------------/* Best viewed using font-face 'Consolas' */// #################################//// -----------		SETTINGS//// Default settings for first-time run//// #################################// Window size and location	if(!`optionVar -ex "aweCPDockWidth"`)		optionVar -iv "aweCPDockWidth" 100;	if(!`optionVar -ex "aweCPDockHeight"`)		optionVar -iv "aweCPDockHeight" 400;	if(!`optionVar -ex "aweCPDockFloat"`)		optionVar -iv "aweCPDockFloat" 0;	if(!`optionVar -ex "aweCPDockArea"`)		optionVar -sv "aweCPDockArea" "left";	if(!`optionVar -ex "aweCPDockPosition"`) {		optionVar -iva "aweCPDockPosition" 50;		optionVar -iva "aweCPDockPosition" 130;	}		// MarkingMenu Settings	// Tabs to display			DEFAULT: Single	if(!`optionVar -ex "aweCPMMTabs"`)		optionVar -iv "aweCPMMTabs" 1;	// Enabled Panels			DEFAULT: Viewport, GraphEditor	if(!`optionVar -ex "aweCPMMViewPanes"`)		optionVar -iv "aweCPMMViewPanes" 1;	if(!`optionVar -ex "aweCPMMGraphEditor"`)		optionVar -iv "aweCPMMGraphEditor" 1;	if(!`optionVar -ex "aweCPMMOutliner"`)		optionVar -iv "aweCPMMOutliner" 0;	if(!`optionVar -ex "aweCPMMHypershade"`)		optionVar -iv "aweCPMMHypershade" 0;		// Display Settings	// Show Prefix				DEFAULT: True	if(!`optionVar -ex "aweCPDisplayPrefix"`)		optionVar -iv "aweCPDisplayPrefix" 1;	// Show Tablabels			DEFAULT: True	if(!`optionVar -ex "aweCPDisplayTabLabels"`)		optionVar -iv "aweCPDisplayTabLabels" 1;	// Picker Shading			DEFAULT: True	if(!`optionVar -ex "aweCPDisplayShadedPickers"`)		optionVar -iv "aweCPDisplayShadedPickers" 1;	// UI Resizing				DEFAULT: Off	if(!`optionVar -ex "awCPDisplayResizeDock"`)		optionVar -iv "aweCPDisplayResizeDock" 0;	// Prefix Mode				DEFAULT: Hierarchy	if(!`optionVar -ex "aweCPPrefixMode"`)		optionVar -sv "aweCPPrefixMode" "Hierarchy";	// Picker Hiliting			DEFAULT: On	if(!`optionVar -ex "aweCPHilitePickers"`)		optionVar -iv "aweCPHilitePickers" 1;// Picker Key Settings	// Key all Objects 			DEFAULT: All	if(!`optionVar -ex "aweCPPickerKeyObjects"`)		optionVar -iv "aweCPPickerKeyObjects" 1;	// Key all Channels 		DEFAULT: All	if(!`optionVar -ex "aweCPPickerKeyChannels"`)		optionVar -iv "aweCPPickerKeyChannels" 0;// Debug Mode					DEFAULT: Off	aweCPDebugMode(0);// Global variable to hold the full path to the CPTabLayout, so we can reference it by its full path name// throughout the script without having to worry about other smartass developers creating similar UI	global string $aweCPTabLayout;	// Global variable to identify the dockWidget after it has been created.// Defaults to "aweCPDockWidget" before being created	global string $aweCPDockWidget = "aweCPDockWidget";	// Global variable to identify the Window that acts as parent to all other UI// After being dumped into the dockControl, it is no longer referrable as a Window,// but top-level layouts can be accessed by using this as their pathName	global string $aweCPWindow = "aweCPWindow";	// global variable to hold the ID of the scriptJob that manages Picker hilighting// initially set to -1 to indicate it doesn't exist (yet)	global int $aweCPHiliteJob = -1;// -----------		END SETTINGS// #################################// #################################//// -----------		LOCAL FUNCTIONS//// internal local and helper procs// if a function need not be exposed,// put it here (beware proc order)//// #################################proc aweCPImageExistsUI(string $addButton, string $tabButton, string $optionsButton){	// fallback for missing UI images	/*	//	ensure that UI button images exist before applying them, 	//	so script doesn't fail if not set up correctly	*/		// define a bunch of directory paths in which to search for our images	// default should be ../scripts/aweControlPicker/	string $imageDir 		= (`internalVar -usd` + "aweControlPicker/");	// otherwise the user bitmap directory (../prefs/icons/)	string $altDir 			= `internalVar -ubd`;	// finally, add any script directory Maya knows of	string $scriptPaths    = `getenv "MAYA_SCRIPT_PATH"`;	string $scriptDirs[];	string $token = (`about -mac`) ? ":" : ";";	tokenize($scriptPaths, $token, $scriptDirs);	for($i = 0; $i < size($scriptDirs); $i++) {		$scriptDirs[$i] = ($scriptDirs[$i] + "/aweControlPicker");	}	// add the default and alternative directories to this array	$scriptDirs[size($scriptDirs)] = $imageDir;	$scriptDirs[size($scriptDirs)] = $altDir;	// now find the image, if it exists in any of the paths	string $addDefaultImage = searchPathArray("cpAdd.png", $scriptDirs);	int $addDefault 		= `filetest -r $addDefaultImage`;	string $addDisabledImage = searchPathArray("cpAdd_disabled.png", $scriptDirs);	int $addDisabled 		= `filetest -r $addDisabledImage`;	string $addHiliteImage	= searchPathArray("cpAdd_hilite.png", $scriptDirs);	int $addHilite			= `filetest -r $addHiliteImage`;	string $tabDefaultImage	= searchPathArray("cpTab.png", $scriptDirs);	int $tabDefault 		= `filetest -r $tabDefaultImage`;	string $tabHiliteImage	= searchPathArray("cpTab_hilite.png", $scriptDirs);	int $tabHilite			= `filetest -r $tabHiliteImage`;	string $optionsDefaultImage = searchPathArray("cpOptions.png", $scriptDirs);	int $optionsDefault 	= `filetest -r $optionsDefaultImage`;	string $optionsHiliteImage = searchPathArray("cpOptions_hilite.png", $scriptDirs);	int $optionsHilite 		= `filetest -r $optionsHiliteImage`;	// apply images if each set exists	if($addDefault && $addDisabled && $addHilite) {		iconTextButton -e			-i $addDefaultImage			-di $addDisabledImage			-hi $addHiliteImage			-st "iconOnly"		$addButton;	}	if($tabDefault && $tabHilite) {		iconTextButton -e			-i $tabDefaultImage			-hi $tabHiliteImage			-st "iconOnly"		$tabButton;	}	if($optionsDefault && $optionsHilite ) {		iconTextButton -e			-i $optionsDefaultImage			-hi $optionsHiliteImage			-st "iconOnly"		$optionsButton;	}}proc aweCPBuildUI() {	// builds main UI		/*	//	Builds the UI from scratch.	//	Uses InitPickers() to create (default) tabs and pickers.	//	The following code just looks long and complicated, but it isn't (complicated). 	//	That's MEL UI building for ya...	//	//	DEPENDS:	aweCPImageExistsUI	*/		global string $aweCPTabLayout;	global string $aweCPDockWidget;	global string $aweCPWindow;		if(`control -q -ex $aweCPDockWidget`) deleteUI $aweCPDockWidget;	if(`control -q -ex $aweCPWindow`) deleteUI $aweCPWindow;		$aweCPWindow = `window -retain aweCPWindow`;			string $masterLayout = `formLayout CPMasterLayout`;					// layout for the main UI buttons			rowLayout	-nc 3	CPUIButtonsLayout;							// buttons created with label only				// image-check follows and re-configures				string $addButton = `iconTextButton					-l "Pckr+"					-st "textOnly"					-ann "Add a picker button for the current selection" 					-c "aweCPEditPicker(\"new\", \"blarf\")"					-rpt 1				CPAddPickerButton`;				string $tabButton = `iconTextButton					-l "Tab+"					-st "textOnly"					-ann "Tab Options"				CPAddTabButton`;				string $optionsButton = `iconTextButton					-l "?"					-st "textOnly"					-ann "Options"				CPOptionsButton`;						// add UI Images if available			aweCPImageExistsUI($addButton, $tabButton, $optionsButton);			setParent..; // to MasterLayout			// layout for the prefix stuff			frameLayout 				-cl 1 -cll 1 				-mh 4 -mw 3 				-bgc .26 .26 .26				-bv 1 				-l "Prefix"				-vis `optionVar -q "aweCPDisplayPrefix"`			CPPrefixLayout;							columnLayout 					-en 1 -adj 1 -rs 4 				CPPrefixContentLayout;									text 						-al "left" -font "boldLabelFont" -l "Mode"					CPPrefixModeText;					optionMenu 						-cc "aweCPTogglePrefixMode #1"					CPPrefixModeMenu;						menuItem 							-l "Hierarchy"							-ann "Enter name of top-most node in the alternative rig's hierarchy"						CPPrefixModeHierarchyItem;													menuItem 							-l "Namespace"							-ann "Enter alternative namespace of otherwise identical rig"						CPPrefixModeNamespaceItem;						menuItem							-l "Prefix"							-ann "Enter the current Prefix and a Prefix to replace it with"						CPPrefixModePrefixItem;					textField						-w 90						-bgc .11 .15 .17						-vis ( (`optionVar -q aweCPPrefixMode` == "Prefix") ? 1 : 0 )						-tx "current prefix"						-ann "Enter existing prefix you want replaced by the alternate prefix"						-rfc "if(`textField -q -tx CPCurrentPrefixEdit` == \"current prefix\") { textField -e -tx \"\" CPCurrentPrefixEdit; }"					CPCurrentPrefixEdit;					textField 						-w 90 						-bgc .16 .12 .12						-tx "alternate prefix"						-ann "Enter alternative string to prefix with"						-rfc "if(`textField -q -tx CPPrefixEdit` == \"alternate prefix\") { textField -e -tx \"\" CPPrefixEdit; }"					CPPrefixEdit;										// set active mode according to optionVar setting					optionMenu -e -v `optionVar -q "aweCPPrefixMode"` CPPrefixModeMenu;									setParent..; // to frameLayout			setParent..; // to MasterLayout						// create the tabLayout			int $displayTabLabels = `optionVar -q "aweCPDisplayTabLabels"`;			$aweCPTabLayout = `tabLayout				-w 100				-imw 0 -imh 2				-tv $displayTabLabels				-scr 1 -cr 1				-dcc "aweCPRenameTab(\"\")"				aweCPTabLayout`;							//populate it with existing pickers (or default)				aweCPInitPickers;				setParent $aweCPTabLayout;			setParent..; // to CPMasterLayout						// create invisible (-height 1, -width 1) scrollLayouts, just to take advantage of			// their -resizeCommand flag for optionVar settings			string $widthCmd = ("optionVar -iv aweCPDockWidth `layout -q -w " + $masterLayout +"`");			string $heightCmd = ("optionVar -iv aweCPDockHeight `layout -q -h " + $masterLayout+"`");			scrollLayout 				-h 1 				-rc $widthCmd			CPHorizontalResizeLayout;			setParent..;			scrollLayout				-w 1				-rc $heightCmd			CPVerticalResizeLayout;			setParent..;				// create move buttons for the tabs		button 			-vis `optionVar -q "aweCPDisplayTabLabels"`			-bgc .24 .24 .24			-h 12 -rs 0			-ann "Move Tab Left"			-c "aweCPMoveTabLeft"			-l "«  " 		CPMoveTabLeftBtn;		button			-vis `optionVar -q "aweCPDisplayTabLabels"`			-bgc .24 .24 .24			-h 12 -rs 0			-c "aweCPMoveTabRight"			-l "  »" 			-ann "Move Tab Right"		CPMoveTabRightBtn;		text			-vis `optionVar -q "aweCPDisplayTabLabels"`			-h 12 -rs 0			-label "move"			-fn "smallPlainLabelFont"			-bgc .24 .24 .24		CPMoveTabText;				// create prev and next tab select buttons		button			-vis (!`optionVar -q "aweCPDisplayTabLabels"`)			-bgc .24 .24 .24			-h 12 -rs 0			-c "aweCPPreviousTab"			-l "« "			-ann "Select Previous Tab"		CPSelectPrevTabBtn;		button			-vis (!`optionVar -q "aweCPDisplayTabLabels"`)			-bgc .24 .24 .24			-h 12 -rs 0			-c "aweCPNextTab"			-l " »"			-ann "Select Next Tab"		CPSelectNextTabBtn;		text			-vis (!`optionVar -q "aweCPDisplayTabLabels"`)			-h 12 -rs 0			-label "select"			-fn "smallPlainLabelFont"			-bgc .24 .24 .24		CPSelectTabText;		// format the CPMasterLayout and its children		formLayout -e 			-af "CPUIButtonsLayout" "top" 4 			-af "CPUIButtonsLayout" "left" 2 			-af "CPUIButtonsLayout" "right" 0			-af "CPPrefixLayout" "left" 2 			-af "CPPrefixLayout" "right" 0			-ac "CPPrefixLayout" "top" 2 "CPUIButtonsLayout"			// tab move buttons			-af "CPMoveTabLeftBtn" "left" 2			-af "CPMoveTabRightBtn" "right" 0			-ac "CPMoveTabLeftBtn" "top" 2 "CPPrefixLayout"			-ac "CPMoveTabRightBtn" "top" 2 "CPPrefixLayout"			-ap "CPMoveTabRightBtn" "left" 0 70			-ap "CPMoveTabLeftBtn" "right" 0 30			-ac "CPMoveTabText" "left" 2 "CPMoveTabLeftBtn"			-ac "CPMoveTabText" "right" 2 "CPMoveTabRightBtn"			-ac "CPMoveTabText" "top" 2 "CPPrefixLayout"			// tab select buttons			-af "CPSelectPrevTabBtn" "left" 2			-af "CPSelectNextTabBtn" "right" 0			-ac "CPSelectPrevTabBtn" "top" 2 "CPPrefixLayout"			-ac "CPSelectNextTabBtn" "top" 2 "CPPrefixLayout"			-ap "CPSelectNextTabBtn" "left" 0 70			-ap "CPSelectPrevTabBtn" "right" 0 30			-ac "CPSelectTabText" "left" 2 "CPSelectPrevTabBtn"			-ac "CPSelectTabText" "right" 2 "CPSelectNextTabBtn"			-ac "CPSelectTabText" "top" 2 "CPPrefixLayout"			// tablayout			-ac "aweCPTabLayout" "top" 15 "CPPrefixLayout" 			-af "aweCPTabLayout" "left" 2 			-af "aweCPTabLayout" "right" 0			-af "aweCPTabLayout" "bottom" 2			// resize layouts			-af "CPHorizontalResizeLayout" "left" 0			-af "CPHorizontalResizeLayout" "right" 0			-af "CPVerticalResizeLayout" "top" 0			-af "CPVerticalResizeLayout" "bottom" 0		$masterLayout;					// now create the various popupMenus				// OPTIONS menu		string $optionsMenu = `popupMenu			-p $optionsButton			-b 1		CPOptionsMenu`;			menuItem				-l "Save Pickers"				-ann "Save Pickers to a file"				-c "aweCPSavePickers()"				-ecr 0				-p $optionsMenu			CPOptionsSaveItem;			menuItem				-l "Load Pickers"				-ann "Load Pickers from a file"				-c "aweCPLoadPickers()"				-ecr 0				-p $optionsMenu			CPOptionsLoadItem;						menuItem				-divider 1				-p $optionsMenu			CPOptionsDividerItem1;						// MARKINGMENU			$mmSubMenu = `menuItem				-l "MarkingMenu"				-ann "MarkingMenu Settings"				-sm 1				-tearOff 1				-p $optionsMenu			CPMMSettingsSubmenu`;				$rbMMCollection = `radioMenuItemCollection`;				menuItem					-rb `optionVar -q "aweCPMMTabs"`					-cl $rbMMCollection					-l "Show only current tab"					-ann "MarkingMenu will only show Pickers in the currently selected tab"					-c "optionVar -iv aweCPMMTabs 1"					-p $mmSubMenu				CPMMTabSettingsRB1;				menuItem					-rb (!`optionVar -q "aweCPMMTabs"`)					-cl $rbMMCollection					-l "Show all tabs"					-ann "MarkingMenu will display submenus for Pickers in each tab"					-c "optionVar -iv aweCPMMTabs 0"										-p $mmSubMenu				CPMMTabSettingsRB2;				menuItem					-divider 1					-p $mmSubMenu				CPMMDividerItem;				menuItem					-cb `optionVar -q aweCPMMViewPanes`					-l "Show in Viewport"					-ann "Show MarkingMenu in Modeling Viewports"					-c "optionVar -iv aweCPMMViewPanes `menuItem -q -cb CPMMinViewportItem`;"					-p $mmSubMenu				CPMMinViewportItem;				menuItem					-cb `optionVar -q aweCPMMGraphEditor`					-l "Show in Graph Editor"					-ann "Show MarkingMenu in the Graph Editor"					-c "optionVar -iv aweCPMMGraphEditor `menuItem -q -cb CPMMinGraphEditorItem`;"					-p $mmSubMenu				CPMMinGraphEditorItem;				menuItem					-cb `optionVar -q aweCPMMOutliner`					-l "Show in Outliner"					-ann "Show MarkingMenu in the Outliner"					-c "optionVar -iv aweCPMMOutliner `menuItem -q -cb CPMMinOutlinerItem`;"					-p $mmSubMenu				CPMMinOutlinerItem;				menuItem					-cb `optionVar -q aweCPMMHypershade`					-l "Show in Hypershade"					-ann "Show MarkingMenu in the Hypershade"					-c "optionVar -iv aweCPMMHypershade `menuItem -q -cb CPMMinHypershadeItem`;"					-p $mmSubMenu				CPMMinHypershadeItem;							// Display Settings			$displaySettings = `menuItem				-l "UI Display"				-p $optionsMenu				-ann "UI Display Settings"				-sm 1			CPDisplaySettingsSubMenu`;				menuItem					-p $displaySettings					-l "Display Shaded Pickers"					-ann "Make Pickers appear shaded or flat"					-c "aweCPToggleShadedPickers"					-cb `optionVar -q "aweCPDisplayShadedPickers"`				CPDisplayShadedPickersItem;				menuItem					-p $displaySettings					-l "Show Prefix Editor"					-ann "Show or Hide the Prefix Editor"					-c "aweCPTogglePrefixEditor"					-cb `optionVar -q "aweCPDisplayPrefix"`				CPDisplayPrefixItem;				menuItem					-p $displaySettings					-l "Show Tab Labels"					-ann "Show or Hide Tab labels"					-c "aweCPToggleTabLabels"					-cb `optionVar -q "aweCPDisplayTabLabels"`				CPDisplayTabLabelsItem;				menuItem					-p $displaySettings					-d 1				CPDisplayDividerItem;				menuItem					-p $displaySettings					-l "Hilite Pickers"					-ann "Hilight Pickers that have associated objects currently selected"					-c "aweCPTogglePickerHilite"					-cb `optionVar -q "aweCPHilitePickers"`				CPDisplayHilitePickersItem;				menuItem					-p $displaySettings					-l "Resize UI for Tabs"					-ann "Automatically resize UI to accomodate any changes to Tabs"					-c "aweCPToggleResizeDock"					-cb `optionVar -q "aweCPDisplayResizeDock"`				CPDisplayResizeDockItem;						// PICKER SETTINGS			$pickerSettings = `menuItem				-l "Set Key Options"				-p $optionsMenu				-ann "Picker Behaviour"				-sm 1				-tearOff 1			CPPickerSettingsSubMenu`;				$rbKeyCollection = `radioMenuItemCollection`;				menuItem					-p $pickerSettings					-l "Key all objects"					-ann "Ctrl-click sets keys on all objects"					-rb `optionVar -q "aweCPPickerKeyObjects"`					-cl $rbKeyCollection					-c "aweCPToggleKeySettings(1)"				CPPickerSettingsKeyRB1;				menuItem					-p $pickerSettings					-l "Key animated objects"					-ann "Ctrl-click sets keys only on objects that already have keys"					-rb (!`optionVar -q "aweCPPickerKeyObjects"`)					-cl $rbKeyCollection					-c "aweCPToggleKeySettings(0)"				CPPickerSettingsKeyRB2;				menuItem					-p $pickerSettings					-l "Animated channels only"					-ann "Set keys only on channels that already have keys"					-cb `optionVar -q "aweCPPickerKeyChannels"`					-en (!`optionVar -q "aweCPPickerKeyObjects"`)					-c "optionVar -iv aweCPPickerKeyChannels `menuItem -q -cb CPPickersSettingsChannelItem`"				CPPickersSettingsChannelItem;			menuItem				-divider 1				-p $optionsMenu			CPOptionsDividerItem2;						// Other Settings			menuItem				-l "Re-Initialize Pickers"				-ann "Scan scene for picker data and rebuild"				-c "aweCPInitPickers"				-ecr 0				-p $optionsMenu			CPOptionsReInitItem;			menuItem				-l "Reset"				-ann "Reset UI"				-c "evalDeferred(\"aweCPReset\")"				-ecr 0				-p $optionsMenu			CPOptionsResetItem;			menuItem				-l "Help"				-ann "Show Help Window"				-c "aweCPShowHelp"				-ecr 0				-p $optionsMenu			CPOptionsHelpItem;				// TAB menu		string $tabMenu = `popupMenu			-p $tabButton			-b 1		CPTabMenu`;			menuItem				-l "New Tab"				-ann "Create a new Tab"				-c "aweCPNewTab(\"\")"				-ecr 0				-p $tabMenu			CPTabNewItem;			menuItem				-l "Rename Tab"				-ann "Rename currently selected tab"				-c "aweCPRenameTab(\"\")"				-ecr 0				-p $tabMenu			CPTabRenameItem;			menuItem				-divider 1				-p $tabMenu			CPTabDividerItem;			menuItem				-l "Delete Tab"				-ann "Delete currently selected tab"				-c "aweCPDeleteTab()"				-ecr 0				-p $tabMenu			CPTabDeleteItem;	// create the dockWidget	$dWidth = `optionVar -q "aweCPDockWidth"`;	$dArea = `optionVar -q "aweCPDockArea"`;		$aweCPDockWidget = `dockControl		-w $dWidth		-l "aweControlPicker" 		-aa "left" 		-aa "right" 		-a $dArea		-content "aweCPWindow"	aweCPDockWidget`;		// set the -floating state after creating it, or else it bugs out	int $isDockFloating = `optionVar -q "aweCPDockFloat"`;	if($isDockFloating) {		dockControl -e -h `optionVar -q "aweCPDockHeight"` $aweCPDockWidget;		dockControl -e -fl $isDockFloating $aweCPDockWidget;		int $dockPos[] = `optionVar -q "aweCPDockPosition"`;		window -e -le $dockPos[0] -te $dockPos[1] $aweCPDockWidget;	}	// for convenience, create a dimWhen listener to deactive the AddPicker button if nothing is selected	dimWhen -f SomethingSelected $addButton;		// create scriptJobs to handle various changes to the scene	//	// re-initialize Pickers on scene:New or scene:Open	scriptJob -p $aweCPDockWidget -e "deleteAll" "aweCPInitPickers()";		// re-initialize Pickers on scene:Import or scene:Reference	// this only works on Maya 2012+	if(`getApplicationVersionAsFloat` >= 2012) {		scriptJob -p $aweCPDockWidget -e "PostSceneRead" "aweCPInitPickers()";	}		// take care of hilighting Pickers with active objects	if(`optionVar -q "aweCPHilitePickers"`) {		global int $aweCPHiliteJob;		if(!`scriptJob -ex $aweCPHiliteJob`) {			int $hiliteJob = `scriptJob -p $aweCPDockWidget -e "SelectionChanged" "aweCPUpdateHilite()"`;			$aweCPHiliteJob = $hiliteJob;		}	}		// save UI information on application:Quit	scriptJob -p $aweCPDockWidget -e "quitApplication" "aweCPStoreUIPrefs";	}proc string aweCPGetLabel(string $setName) {	// retrieve a Picker or Tab label		/*	//	given the name of an objectSet, queries the set's label attribute	//	//	RETURNS:	string "labelName"	*/			string $label = `getAttr ($setName + ".CP_Label")`;	return $label;}proc float[] aweCPGetColor(string $setName){	// retrieve a Picker's color		/*	//	given an objectSet belonging to a Picker, queries the color attribute	//	// 	RETURNS:	array[Color, Color, Color]	*/		float $colors[] = `getAttr ($setName + ".CP_Color")`;	return $colors;	}proc int aweCPGetIndex(string $setName){	// retrieve a Picker or Tab index		/*	//	given an objectSet, queries the attached UI index attribute	//	//	RETURNS:	int "index"	*/		int $index = `getAttr ($setName + ".CP_Index")`;	return $index;}proc string aweCPGetType(string $setName){	// retrieve type of set		string $type = `getAttr ($setName + ".CP_Type")`;	return $type;}proc string[] aweCPListTabSets(string $filter){	// lists all existing tab objectSets in the scene		/*	//	Scans scene for objectSets that are classified as CP_Type: tab	//	$filter can be one of the following values:	//	"all": returns all tabSets in the scene	//	"referenced": returns only referenced tabSets	//	"imported": returns non-referenced tabSets that have prefixes	//	//	RETURNS:	array[tabObjectSets]	//	//	DEPENDS:	aweCPGetType	*/		// first we simply gather all objectSets based on $filter	string $sets[];	string $tabSets[];	if($filter == "all") {				$sets = `ls -type "objectSet"`;	} 	else if($filter == "referenced") {  			$sets = `ls -type "objectSet" -rn`;	}	else if($filter == "imported") {				$tempSets = `ls -type "objectSet"`;		for($s in $tempSets) {			if(	(!`referenceQuery -inr $s`) 			&&	(!startsWith($s, "aweCP_tab")) ) {								$sets[size($sets)] = $s;			}		}			}		// now we gather only those that qualify as tabSets	for($set in $sets) {				if(	(attributeExists("CP_Type", $set)) 		&& 	(aweCPGetType($set) == "tab") ) {								$tabSets[size($tabSets)] = $set;		}	}	return $tabSets;	}proc string aweCPGetPickerSet(string $picker){	// returns the objectSet associated with a Picker		/*	//	takes a Picker button control as input and	//	finds the objectSet associated with it	//	//	RETURNS:	string "objectSet"	*/		string $layout = `control -q -p $picker`;	string $nameField = ($layout + "|CPNameField");	string $objectSet = `nameField -q -o $nameField`;		return $objectSet;}proc string aweCPGetTabSet(string $type, string $input){	// returns the objectSet associated with a tab		/*	//	depending on $type, will find the objectSet that	//	matches either the tabs label or its layoutName	//	Valid types are 'label' and 'layout'	//	//	RETURNS:	string "objectSet" OR "null" if set not found	//	//	DEPENDS:	aweCPListTabSets, aweCPGetLabel	*/		global string $aweCPTabLayout;	// we will need the label anyway, so get it	string $label;	if($type == "layout") {		string $layoutArray[] = `layout -q -ca $aweCPTabLayout`;		string $labelArray[] = `tabLayout -q -tl $aweCPTabLayout`;		for($i = 0; $i < size($layoutArray); $i++) {			if($layoutArray[$i] == $input) {				$label = $labelArray[$i];				break;			}		}	}	else {		$label = $input;	}		string $tabSet;	// now that we have the label, see if any set matches it	string $tabSets[] = aweCPListTabSets("all");	for($set in $tabSets) {		if(aweCPGetLabel($set) == $label) {			$tabSet = $set;			break;		}		}		if(size($tabSet)) {		return $tabSet;	}	else {		return "null";	}}			proc string aweCPMakeValidTabLabel(string $inputString){	// strips invalid characters from a tab label		/*	//	Define a set of invalid characters and remove them	//	from the input string	//	//	RETURNS:	a 'clean' version of the input string	*/		// define invalid characters here	string $invalidCharsArray[] = {":", " ", ",", "%", "_" };	string $invalidChars = stringArrayToString($invalidCharsArray, "");	string $invalidRegEx = ("[^" + $invalidChars + "]*");	string $subRegEx = ("[" + $invalidChars + "]");	string $result = $inputString;	int $stripped = 0;  while(!isValidString($result, $invalidRegEx)) {			$result = `substitute $subRegEx $result ""`;		$stripped = 1;  }	if($stripped) 		print("// aweCP Warning: Invalid characters ( % , _ : ) removed from label\n");		return $result;}proc string aweCPMakeValidPickerLabel(string $inputString){	// strips invalid characters from a picker label		/*	//	Define a set of invalid characters and remove them	//	from the input string; outputs a warning if invalid	//	characters were found/stripped	//	//	RETURNS:	string "cleanLabel"	*/		// define invalid characters here	string $invalidCharsArray[] = {":", ",", "%"};	string $invalidChars = stringArrayToString($invalidCharsArray, "");	string $invalidRegEx = ("[^" + $invalidChars + "]*");	string $subRegEx = ("[" + $invalidChars + "]");	string $result = $inputString;	int $stripped = 0;  while(!isValidString($result, $invalidRegEx)) {			$result = `substitute $subRegEx $result ""`;		$stripped = 1;  }	if($stripped) 		print("// aweCP Warning: Invalid characters ( % , : ) removed from label\n");		// finally, check if the result starts with "tab", because that might confuse the script	// convert any string "tab" at beginning to "TAB"	string $tabSubStr = match("^(tab)*", $result);	if(size($tabSubStr)) {		string $noTabSubStr = match("[^(tab)]*$", $result);		$result = ("TAB" + $noTabSubStr);	}		return $result;}proc string aweCPFormTabSet(string $label){	// forms a tab's objectSet name		/*	//	given a label, returns an appropriate name for an attached tab objectSet	//	e.g. "RIG:myPickers" --> "RIG:aweCP_tab_myPickers"	//	//	RETURNS:	string "objectSet"	*/		// first, check for namespaces	string $namespace = match("^.*:", $label);	string $tabName = match("[^:]*$", $label);	string $setName = ($namespace + "aweCP_tab_" + $tabName);		return $setName;		}proc string aweCPFormPickerSet(string $pickerLabel){	// forms a Picker's objectSet name		/*	//	given a pickerLabel, returns an appropriate name for 	//	an attached Picker objectSet (assumes labels to be valid)	//	//	RETURNS:	string "objectSet"	*/		string $label = ("aweCP_" + $pickerLabel + "_PCKR");	return $label;}proc string aweCPCreatePickerSet(string $name, string $label, float $color[], int $index){	// creates a Picker's objectSet		/*	//	given the necessary data, creates an objectSet to be used by a Picker	//	//	RETURNS:	string "setName"	*/	string $pickerSet = `sets -empty -name $name`;	// add the attributes for label, color and index	addAttr -dt "string" -ln "CP_Type" -hidden 1 $pickerSet;	addAttr -dt "float3" -ln "CP_Color" -hidden 1 $pickerSet;	addAttr -dt "string" -ln "CP_Label" -hidden 1 $pickerSet;	addAttr -at "short" -ln "CP_Index" -hidden 1 $pickerSet;	addAttr -dt "string" -ln "CP_UI" -hidden 1 $pickerSet;	setAttr ($pickerSet + ".CP_Type") -type "string" "picker";	setAttr ($pickerSet + ".CP_Label") -type "string" $label;	setAttr ($pickerSet + ".CP_Color") -type "float3" $color[0] $color[1] $color[2];	setAttr ($pickerSet + ".CP_Index") $index;		return $pickerSet;}proc string aweCPCreateTabSet(string $name, string $label, int $index){	// creates a Tab's objectSet		/*	//	given the necessary data, creates an objectSet to be used by a tab	//	//	RETURNS:	string "setName"	*/		string $tabSet = `sets -em -name $name`;	addAttr -ln "CP_Type" -dt "string" -hidden 1 $tabSet;	addAttr -ln "CP_Label" -dt "string" -hidden 1 $tabSet;	addAttr -ln "CP_Index" -at "short" -hidden 1 $tabSet;	setAttr ($tabSet + ".CP_Type") -type "string" "tab";	setAttr ($tabSet + ".CP_Index") $index;	setAttr ($tabSet + ".CP_Label") -type "string" $label;		return $tabSet;}proc string aweCPNewPicker(int $new, string $tabLayout, string $label, float $color[], string $objects[]) {	// creates a Picker button		/*	//	called from the PCKR(+) button or from the Load function.	//	Takes button configuration (tab, label, color) and stringArray of objects as input;	//	if $new = 1, an objectSet is created, otherwise just the Picker without objectSet	//	//	RETURNS:	string "fullPath|controlName"	//	//	DEPENDS:	aweCPFormPickerSet, aweCPCreatePickerSet, aweCPFormTabSet, aweCPCreateMenu	*/		global string $aweCPTabLayout;		// first, figure out the layout (tab-dependent) that will hold our button	string $tabLayoutArray[] = `layout -q -ca $aweCPTabLayout`;	int $ti;	for($x = 0; $x < size($tabLayoutArray); $x++) {		if($tabLayoutArray[$x] == $tabLayout) {			$ti = $x;			break;		}	}	string $tabLabelArray[] = `tabLayout -q -tl $aweCPTabLayout`;	string $tabLabel = $tabLabelArray[$ti];		// find unique name for layout; 999 seems a reasonable cap	// as buttons are deleted, their names automatically become available again	string $btnLayoutName;	int $i;	for($i=0;$i<999; $i++) {		string $children[] = `layout -q -ca $tabLayout`;		$btnLayoutName = ("CPBtnLayout_" + $i);		if(!stringArrayContains($btnLayoutName, $children)) {			break;		}	}		// this is the parent layout each button gets	int $isShaded = `optionVar -q "aweCPDisplayShadedPickers"`;	// changed in 1.0.2, now the btnLayout has the dropCallback	// because OSX doesn't support dropCallbacks on iconTextButtons	$btnLayout = `columnLayout 			-parent $tabLayout 			-adj 1			-bgc .1 .1 .1			-rs $isShaded			-dpc "aweCPBtnDropCB"		$btnLayoutName`;		// create a nameField to link to the objectSet	string $nameField = `nameField -m 0 -p $btnLayout "CPNameField"`;		// is this a new picker or are we loading existing pickers?	// we don't need an objectSet if we are loading	if($new) {				// what position in the tab is this button?		int $index = `layout -q -nch $tabLayout`;		// create an objectSet to hold associated objects		string $setName = aweCPFormPickerSet($label);		string $pickerSet = aweCPCreatePickerSet($setName, $label, $color, $index);		setAttr ($pickerSet + ".CP_UI") -type "string" $btnLayout;		// place the pickerSet within its tabSet		string $tabSet = aweCPFormTabSet($tabLabel);		sets -e -add $tabSet $pickerSet;		sets -e -add $pickerSet $objects;		// link nameField to objectSet		nameField -e -o $pickerSet $nameField;	}	// create the picker button	string $pickerStyle = (`optionVar -q "aweCPDisplayShadedPickers"`) ? "iconAndTextHorizontal" : "textOnly";	string $button = `iconTextButton				-h 18 -w 100				-p $btnLayout 				-l $label 				-ann "Hold Shift to Toggle Selection    \nHold Ctrl to Set Key    \nHold Alt to use Prefix"				-image "cpPicker_Icon.png"				-bgc $color[0] $color[1] $color[2]				-style $pickerStyle				-dgc "aweCPBtnDragCB"				//-dpc "aweCPBtnDropCB" //now on btnLayout due to OSX		("CPPickerBtn")`;		// add the select command to this picker	iconTextButton -e		-c ("aweCPClick(\"" + $button  + "\")") 		$button;		// create popupMenu for this button	evalDeferred("aweCPCreateMenu " + $button + " " + $i);	return $button;}proc string[] aweCPFilterKeyObjects(string $objectArray[]){	// filters objects based on having keys	/*	//	Given an array of objects, filters the list according to the	//	method stored in the optionVars 'aweCPPickerKeyObjects' and 'aweCPPickerKeyChannels'.	//	The possible methods are:	//	'all': returns unaltered objectArray	//	[OR]	//	'allKeyed': returns objects that have keys on them	//	[AND/OR]	//	'channels': replaces objects with object.attribute array based on previously keyed channels	//	This proc is called from aweCPClick()	//	//	RETURNS:	array["filteredObjectList"]	*/	string $returnArray[];	// first, do we key all or 'keyed only'?	int $keyMethod = `optionVar -q "aweCPPickerKeyObjects"`;	// key all	if($keyMethod == 1) {		$returnArray = $objectArray;	}	// key animated only	else {		// create an array filled with objects that are animated		string $keyedObjects[];		for($obj in $objectArray) {			if(`keyframe -q -kc $obj`) {				$keyedObjects[size($keyedObjects)] = $obj;			}		}		// key all channels or only those with animCurves?		int $channelMethod = `optionVar -q "aweCPPickerKeyChannels"`;		// key animated channels only:		if($channelMethod) {			/*			// lsThroughFilter is useless, we have to bruteforce this			*/			string $attrFilter = `itemFilterAttr -hc 1`;			// loop through each object			for($obj in $keyedObjects) {				string $attributes[] = `listAttr -k $obj`;				for($attr in $attributes) {					string $attrName = ($obj + "." + $attr);					string $animAttr[] = `lsThroughFilter -item $attrName $attrFilter`;										if(size($animAttr)) {						$returnArray[size($returnArray)] = $animAttr[0];					}				}							}			delete $attrFilter;		}		// key all channels; we return the array of objects that have existing keys		else {			$returnArray = $keyedObjects;		}	}	return $returnArray;}proc string[] aweCPPrefixHierarchy(string $objectArray[], string $prefix) {	// prefixes Picker objects based on Hierarchy		/*	//	Takes a string array of DAG paths and a prefix as input	//	replaces top-level node of each path with $prefix	//	//	RETURNS:	array["objectDAGPath"]	*/	string $newObjectArray[];		// pattern matching to find that top level node	// format: [(optional) |  _] [someName] [(optional) _ Numbers Letters]	// 	// note to self: stop being so complicated and just use rootOf(), you muppet!	string $regEx = "^|*[A-z]+[0-9_]*[A-z]*";		for($o in $objectArray) {				string $newPath = substitute($regEx, $o, $prefix);		$newObjectArray[size($newObjectArray)] = $newPath;	}		return $newObjectArray;}proc string[] aweCPPrefixNamespace(string $objectArray[], string $prefix) {	// prefixes Picker objects based on Namespace		/*	//	takes a string array of DAG paths and a prefix as input	//	and replaces any namespace with "prefix:"; 	//	if $prefix is empty, the new namespace will simply be ":" (root)	//	//	Current limitation: only works for root and namespaces that are direct 	//	children of :root; grandchild namespaces may not get parsed correctly	//	//	RETURNS:	array["objectDAGPath"]	*/	string $newObjectArray[];	string $newPrefix = ($prefix + ":");	for($o in $objectArray) {				string $newPath;				// first, determine whether source path actually has a namespace		// match a regular Expression forming a typical namespace to the start of the path		string $regEx = "^|*[A-z]+[0-9_]*[A-z]*:+";		string $namespace = match($regEx, $o);				// if $namespace isn't empty, the namespace was found		if(size($namespace)) {					// a full DAG path might be preceded by a | (pipe), which might get			// matched into the namespace; strip it			if(startsWith($namespace, "|")) {				$namespace = endString($namespace, (size($namespace)-1));			}			// first, strip existing namespace from path			string $noPrefixPath = stripPrefixFromName($namespace, $o);			// then append the new prefix as namespace to the (cleaned) path			$newPath = addPrefixToName($newPrefix, $noPrefixPath);		}				// if $namespace was empty, we assume the source was in :root		// so we simply append the new prefix to it		else {			$newPath = addPrefixToName($newPrefix, $o);		}		//populate the return array with this path		$newObjectArray[size($newObjectArray)] = $newPath;	}		return $newObjectArray;}proc string[] aweCPPrefixPrefix(string $objectArray[], string $currentPrefix, string $replacePrefix){	// prefix Picker objects by replacing existing prefix		/*	//	Yes, the proc name is weird, but it matches the chosen nomenclature...	//	Takes a string array of DAG paths, a prefix and a replacement as input	//	Replaces the current prefix with the replacement string on every object in the array	//	if $currentPrefix is empty, the new prefix will simply be prepended.	//	//	This function first tries to prefix just the base objectname (without DAG path) and return that.	//	If the resulting object is still not unique (or doesn't exist), it will try prefixing every	//	item in the DAG path and return that.	//	//	RETURNS:	array["objectDAGPath"]	*/		string $newObjectArray[];		for($o in $objectArray) {				string $shortName = shortNameOf($o);		string $strippedName = stripPrefixFromName($currentPrefix, $shortName);		string $newShortName = ($replacePrefix + $strippedName);				string $matchObjects[] = `ls $newShortName`;				// is the new object unique?		if(size($matchObjects) == 1) {			$newObjectArray[size($newObjectArray)] = $newShortName;		}				// if the object isn't unique (size > 1) or doesn't exist (size = 0),		// prefix the entire DAG path and place that in the result array.		// The CPSelect function will gracefully catch and handle invalid results		else {						string $strippedPath = stripPrefixFromName($currentPrefix, $o);			string $prefixedPath = addPrefixToName($replacePrefix, $strippedPath);						$newObjectArray[size($newObjectArray)] = $prefixedPath;		}	}		return $newObjectArray;}proc string[] aweCPFindPopupParent(){	// find the parent panel for the MarkingMenu		/*	//	this is copied from the native script 'findPanelPopupParent.mel'	//	recreated and modified here to return not just the parent panel,	//	but also the panel type as array	//	//	RETURNS:	array["parentPanel", "panelType"]	*/		// get panel under cursor	string $panel = `getPanel -up`;		string $parent, $panelType;		if (`panel -q -ex $panel`) {		// get the paneLayout parent of this panel		$c = `layout -q -p $panel`;		// loop through parents until said parent is a paneLayout		while (!`paneLayout -q -ex $c`) {			$c = `control -q -p $c`;		}		if (`paneLayout -q -ex $c`)			$parent = $c;	}	// by default, assume $panel to be the viewPanes paneLayout	else {		$parent = "viewPanes";	}		// now get the panelType	$panelType = `getPanel -to $panel`;	if($panelType == "scriptedPanel") {		$panelType = `scriptedPanel -q -type $panel`;	}		return {$parent, $panelType};}	proc int aweCPIsTabUnique(string $label){	// check whether a tab label is unique		/*	//	Looks at all tab labels in the existing UI	//	(!) not in the objectSets (!)	//	and checks wither the input label is unique among them	//	//	RETURNS:	int True|False 	*/	global string $aweCPTabLayout;		int $isUnique = 1;	string $tabArray[] = `tabLayout -q -tl $aweCPTabLayout`;	for($tab in $tabArray) {		if($tab == $label) {			$isUnique = 0;			break;		}	}		return $isUnique;}proc string[] aweCPGetSortedPickers(string $sets[]){	// re-order a list of pickers by their stored position		/*	//	given a list of pickerSets, retrieve the button-position stored	// 	in their index attribute and sort all sets in ascending order	//	//	RETURNS:	array["SortedPickerSets"]	//	//	DEPENDS:	aweCPGetIndex	*/		string $sortedSets[];	for($set in $sets) {		int $index = (aweCPGetIndex($set) - 1);		$sortedSets[$index] = $set;	}		// if this array originated from the load function, indices don't start	// at 1 and are not consecutive; there will be empty entries littered throughout:	// remove all empty entries	$sortedSets = stringArrayRemove({""}, $sortedSets);		return $sortedSets;}proc string[] aweCPGetSortedTabs(string $sets[]){	// re-order a list of tabs by their stored postion		/*	//	given a list of tabSets, retrieve the tab-position stored in 	//	their index attribute and sort all sets in ascending order	//	//	RETURNS:	array["SortedTabSets"]	//	//	DEPENDS:	aweCPGetIndex	*/	string $sortedSets[];	for($set in $sets) {				int $index = (aweCPGetIndex($set) - 1);		// if for some reason there are overlapping indices, deal with this		// by placing the offending set at the end of the array + $index		// The resulting list may not be accurate, but all sets will be accounted for		if( size($sortedSets[$index]) ) {			$sortedSets[size($sortedSets) + $index] = $set;		}		else {			$sortedSets[$index] = $set;		}	}		// delete empty entries	$sortedSets = stringArrayRemove({""}, $sortedSets);		return $sortedSets;}proc aweCPDeleteAllPickers(){	// deletes all Pickers and Tabs		/*	//	Deletes objectSets and tabLayout UIs without rebuilding UI	//	Referenced sets are automatically preserved due to them not being deletable	*/		global string $aweCPTabLayout;		// delete all the tab- and pickerSets, identified as having the appropriate attributes	string $allSets[] = `ls -type "objectSet"`;	for($set in $allSets) {		int $isCPSet = attributeExists ("CP_Type", $set);		if( $isCPSet ) {			// catchQuiet because the parent set is deleted if the last child is deleted			catchQuiet(`delete $set`);		}	}		// delete tabLayouts	string $tabLayouts[] = `layout -q -ca $aweCPTabLayout`;	for($tab in $tabLayouts) {		deleteUI $tab;	}}proc aweCPCheckImportedSets(){	// checks scene for referenced and imported CP Sets		/*	//	Scan the scene for CP objectSets that are either imported or referenced.	//	Imported sets are 'cleaned up', i.e. prefixes are stripped.	//	Referenced sets have their labels modified to identify them as such.	//	In both cases we need to ensure uniqueness of all labels.	//	//	Call this procedure before or during aweCPInit()	//	//	DEPENDS:	aweCPListTabSets, aweCPGetLabel	*/ 		// we begin by defining an array to hold all currently existing valid tabLabels	string $tabLabels[];	string $refTabs[] = aweCPListTabSets("referenced");	string $importedTabs[] = aweCPListTabSets("imported");	string $allTabs[] = aweCPListTabSets("all");	// validTabs are 'all' minus 'ref' and 'imported'	string $validTabs[] = stringArrayRemove(stringArrayCatenate($refTabs, $importedTabs), $allTabs);		// first, fill the array with existing, non-referenced and non-imported tabLabels	// such are assumed exist within the scene already and be valid due to this process having been	// run on them before or when they were created	for($tab in $validTabs) {		string $label = aweCPGetLabel($tab);		$tabLabels[size($tabLabels)] = $label;	}		// now, lets work on the referenced sets		for($tab in $refTabs) {				// get the prefix, which we artificially ensure to be colon-separated		string $prefix = `substitute "aweCP" $tab ":"`;	  $prefix = match("^[^:]*", $prefix);	  // if the reference is not namespaced, prefix will have an unwanted trailing underscore;	  if(endsWith($prefix, "_")) {	  	$prefix = startString($prefix, (size($prefix) - 1));	  }		// retrieve and modify the label, if necessary		string $label = aweCPGetLabel($tab);		string $newLabel;		if(startsWith($label, $prefix)) {			$newLabel = $label;		}		else {			$newLabel = ($prefix + ":" + $label);		}				// now see if this label is unique		int $i = 1;		string $uniqueLabel = $newLabel;		while(stringArrayContains($uniqueLabel, $tabLabels)) {			$uniqueLabel = ($newLabel + $i);			$i++;		}		setAttr($tab + ".CP_Label") -type "string" $uniqueLabel;		$tabLabels[size($tabLabels)] = $uniqueLabel;	}	// finally, we clean up imported sets		for($tab in $importedTabs) {				// basically we get the name after the prefix and use that as the new name		// this gets rid of the prefix and any eventual namespace		string $cleanName = match("(aweCP_tab_)+[0-9a-zA-z_]*", $tab);		string $newTab = rename($tab, $cleanName);				// make sure the label is unique and matches the set's name		string $label = substitute("aweCP_tab_", $newTab, "");		int $i = 1;		string $uniqueLabel = $label;		while(stringArrayContains($uniqueLabel, $tabLabels)) {			$uniqueLabel = ($label + $i);			$i++;		}			setAttr($newTab + ".CP_Label") -type "string" $uniqueLabel;				$tabLabels[size($tabLabels)] = $uniqueLabel;				// now we also clean the pickerSets in this tabSet		string $pickerSets[] = `sets -q $newTab`;		string $prefix = substitute($cleanName, $tab, "");		for($picker in $pickerSets) {			string $cleanPicker = substitute($prefix, $picker, "");			rename $picker $cleanPicker;		}	}		}proc string aweCPCheckLabelNamespace(string $label){	// checks if a label's namespace exists and modifies accordingly		/*	//	given a label, analyzes it for an existing namespace prefix;	//	we then check to see whether that namespace exists within the current scene.	//	If it doesn't, strip the namespace and return the 'clean' label,	//	otherwise return the unaltered input	//	//	RETURNS:	string "validLabel"	*/		string $namespace = match("^.*:", $label);	if(size($namespace)) {		$namespace = startString($label, (size($namespace) - 1));		if(`namespace -ex $namespace`) {			return $label;		}		else {			$newLabel = substitute(($namespace + ":"), $label, "");			return $newLabel;		}	}	else {		return $label;	}		}proc aweCPClearHilite(){	// clears all Picker hilites		/*	//	This proc simply iterates through every Picker and sets	//	its background color back to default (0.1)	*/	global string $aweCPTabLayout;		string $tabs[] = `layout -q -ca $aweCPTabLayout`;	for($tab in $tabs) {		string $layouts[] = `layout -q -ca $tab`;		for($layout in $layouts) {			layout -e -bgc .1 .1 .1 ($tab + "|" + $layout);		}	}}// #################################//// -----------		GLOBAL FUNCTIONS//// Called from UI elements etc.//// #################################global proc aweControlPicker() {	// MAIN FUNCTION		/*	//	Checks for existing UI; shows it or builds it	//	//	DEPENDS:	aweCPBuildUI	*/	global string $aweCPDockWidget;		// does it already exist?	if(`control -q -ex $aweCPDockWidget`) {		// is it floating or not? Show accordingly		if(`dockControl -q -fl $aweCPDockWidget`) {			control -e -vis 1 $aweCPDockWidget;			}		// if it's docked, raise it		else {			dockControl -e -vis 1 -raise $aweCPDockWidget;		}	}	// if it doesn't exist, build it	else {		aweCPBuildUI();	}}global proc aweCPInitPickers(){	// scan and build existing Pickers		/*	//	When script is initially run or a new scene is loaded,	//	check for aweCP objectSets that may exists and create	//	tabs and pickers for them (or create default Tab)	//	//	This procedure deletes existing UI and rebuilds it with updated data	//	//	DEPENDS:	aweCPCheckImportedSets, aweCPListTabSets, aweCPGetSortedTabs, aweCPGetSortedPickers	//	........	aweCPGetLabel, aweCPGetColor, aweCPNewPicker, aweCPCreateTabSet, aweCPUpdateUIIndex	//	........	aweCPResizeDock	*/		global string $aweCPTabLayout;		// start by performing a check for any imported or referenced sets;	aweCPCheckImportedSets;		// now store the currently selected tabLabel so we can reselect it later	// Autodesk really needs to fix the tabLayout command to make querying this easier	string $cTabLabels[] = `tabLayout -q -tl $aweCPTabLayout`;	int $cTabIndex = `tabLayout -q -sti $aweCPTabLayout`;	string $selectedTab;	if($cTabIndex) {	 $selectedTab = $cTabLabels[$cTabIndex - 1];	}		// clear any tabs that might still exist	$existingTabs = `layout -q -ca $aweCPTabLayout`;	for($et in $existingTabs) {		deleteUI $et;	}	// now gather all the tabSets	string $tabSets[] = aweCPListTabSets("all");			if(size($tabSets)) {		// loop through tabSets		string $tabSetsSorted[] = aweCPGetSortedTabs($tabSets);		for($tSet in $tabSetsSorted) {						string $tabLabel = aweCPGetLabel($tSet);			string $tabName = ("CP" + formValidObjectName($tabLabel) + "TabLayout");			// create the layout for this tab			string $tabLayout = `columnLayout  					-rs 3 -adj 1 					-p $aweCPTabLayout				$tabName`;			// label and select the tab			tabLayout -e -tl $tabLayout $tabLabel $aweCPTabLayout;			tabLayout -e -st $tabLayout $aweCPTabLayout;						// now that we have the tab, populate it with pickers			string $pickerSets[] = `sets -q $tSet`;			string $pSetsSorted[] = aweCPGetSortedPickers($pickerSets);			for ($pSet in $pSetsSorted) {								// get Picker data				string $pickerLabel = aweCPGetLabel($pSet);				float $colors[] = aweCPGetColor($pSet);				string $objects[] = `sets -q $pSet`;						// create the picker				 string $picker = aweCPNewPicker(0, $tabLayout, $pickerLabel, $colors, $objects);								// now, edit the associated nameField to hold the objectSet name				string $pickerLayout = `control -q -p $picker`;				// add CP_UI attr if this picker originates from earlier version (<1.0.1)				if(!attributeExists("CP_UI", $pSet)) {					addAttr -dt "string" -ln "CP_UI" -hidden 1 $pSet;				}				setAttr ($pSet + ".CP_UI") -type "string" $pickerLayout;				nameField -e -o $pSet ($pickerLayout + "|CPNameField");			}		}	}		// if no sets exist, create default tab	else {		columnLayout			-rs 3 -adj 1			-p $aweCPTabLayout		CPPickersTabLayout;				// there seems to be a delay here, so make sure the layout		// is properly constructed before trying to label it		evalDeferred("tabLayout -e -tli 1 Pickers $aweCPTabLayout");		// create a default objectSet for this tabLayout		aweCPCreateTabSet("aweCP_tab_Pickers", "Pickers", 1);	}		// now we reselect the tab that was active prior to initializing	string $cTabLabels[] = `tabLayout -q -tl $aweCPTabLayout`;	int $selectIndex = 1;	for($t = 0; $t < size($cTabLabels); $t++) {		if($cTabLabels[$t] == $selectedTab) {			$selectIndex = $t + 1;		}			}	catchQuiet(`tabLayout -e -sti $selectIndex $aweCPTabLayout`);			// call CPUpdateUIIndex to make sure the correct value is stored	// in the index attribute of each set (mainly due to how CPLoadPickers() works)	evalDeferred("aweCPUpdateUIIndex");		// resize dock if called for	evalDeferred("aweCPResizeDock");}global proc aweCPUpdateUIIndex(){	// updates stored indices of tabs and pickers		/*	//	Call this function whenever there is a change to	//	the order of Pickers in a tab or tabs themselves.	//	This will make sure that the current position is stored in 	//	the respective objectSet's index attribute for future reference.	//	//	DEPENDS:	aweCPGetTabSet, aweCPGetPickerSet	*/	global string $aweCPTabLayout;			// loop over each tab	string $tabs[] = `layout -q -ca $aweCPTabLayout`;	for($t = 0; $t < size($tabs); $t++) {				string $tab = $tabs[$t];				// what objectSet belongs to this tab?		string $tabLabelArray[] = `tabLayout -q -tl $aweCPTabLayout`;		string $tabLabel = $tabLabelArray[$t];		string $tabSet = aweCPGetTabSet("label", $tabLabel);		// update the tab's index		int $index = $t + 1;		setAttr ($tabSet + ".CP_Index") $index;				// iterate over each Picker		string $pickerLayouts[] = `layout -q -ca $tab`;		for($i = 1; $i <= size($pickerLayouts); $i++) {						// construct (unique) fullPathNames for all elements			string $thisLayout = ($tab + "|" + $pickerLayouts[$i - 1]);			string $pickerBtn = ($thisLayout + "|CPPickerBtn");						string $pickerSet = aweCPGetPickerSet($pickerBtn);			// update the position value, which is $i			setAttr ($pickerSet + ".CP_Index") $i;		}	}}global proc aweCPCreateMenu(string $parent, int $id) {	// creates popupMenu for a Picker		/*	//	Takes the button it will be parented to as input.	//	The ID is just for naming purposes	//	//	DEPENDS:	aweCPGetPickerSet	*/			string $menu = `popupMenu 				-parent $parent -b 3 		("CPBtnMenu_" + $id)`;					menuItem -parent $menu 				-l "Add Selection" 				-ann "Adds currently selected objects to this picker button" 				-c ("aweCPAddSelected(\"" + $parent + "\")") 				CPAddMenuItem;							menuItem -parent $menu 				-l "Remove Selection" 				-ann "Removes currently selected objects from this picker button"				-c ("aweCPRemoveSelected(\"" + $parent + "\")") 				CPRemoveMenuItem;							menuItem -parent $menu -d 1 				CPDividerItem;							menuItem -parent $menu 				-l "Edit Picker" 				-ann "Edit this picker button"				-c ("aweCPEditPicker(\"edit\", \"" + $parent + "\")")				CPEditPickerItem;							menuItem -parent $menu				-l "Clear Objects"				-ann "Remove all objects from this Picker"				-c ("aweCPClearPicker(\"" + $parent + "\")")				CPClearPickerItem;								// disable 'delete' option if referenced			string $pickerSet = aweCPGetPickerSet($parent);			int $isReferenced = `referenceQuery -inr $pickerSet`;						menuItem -parent $menu 				-l "Delete" 				-ann "Deletes this picker button" 				-c ("aweCPDeletePicker(\"" + $parent + "\")") 				-enable (!$isReferenced)				CPDeleteMenuItem;}global proc aweCPEditPicker(string $mode, string $button) {	// Edits a Picker or creates a new one		/*	//	This proc is used to both edit and create Pickers.	//	It invokes a dialog to set or edit the label and color of a Picker. 	//	Before we can call the actual Dialog, we need to do some pre-work; 	//	mainly, deciding whether we are editing or creating a button, and 	//	provide the respective data to BtnDialogUI(). 	//	Subsequently retrieve the new data and, depending on $mode, modify 	//	an existing Picker or call aweCPNewPicker() to create one.	//	$mode is either "edit" or "new". In latter case, $button can be an arbitrary string	//	//	DEPENDS:	aweCPGetTabSet, aweCPEditDialogUI, aweCPNewPicker, aweCPGetPickerSet, aweCPFormPickerSet	*/		global string $aweCPTabLayout;	string $label;	float $color[3];		if($mode == "new") {				// check if this tab is referenced and exit if necessary		string $tabLayout = `tabLayout -q -st $aweCPTabLayout`;		string $set = aweCPGetTabSet("layout", $tabLayout);		if(`referenceQuery -inr $set`) {			print("// aweCP Error: Can't create Pickers in a referenced Tab!\n");			return;		}				// get the first short objectName in the list. This is so much easier in Python		$label = python("import maya.cmds as cmds; a = cmds.ls(sl = True, l = True)[0].rsplit('|',1); a = a[len(a)-1]; a");		// strip any namespaces		$label = match("[^:]*$", $label);		// default colour is light grey		$color = { 0.9, 0.9, 0.9 };	}		if($mode == "edit") {		$label = `iconTextButton -q -l $button`;		$color = `iconTextButton -q -bgc $button`;	}	// we need to convert $color to a stringArray	string $colorString[3];	for($i = 0; $i <= 2; $i++) {		$colorString[$i] = (string) $color[$i];		// store the color as string formatted like a float		if(size($colorString[$i]) == 1) {			$colorString[$i] = ($colorString[$i] + ".0");		}	}	// build the command for the layoutDialog and call it	$uiCmd = ("aweCPEditDialogUI(\"" + $label + "\", {\"" + $colorString[0] + "\", \"" + $colorString[1] + "\", \"" + $colorString[2] + "\"})");	string $result = `layoutDialog -t "Edit Picker" -ui $uiCmd`;		if($result != "dismiss") {				string $resultList[];		tokenize $result ":" $resultList;		string $newLabel = $resultList[0];		string $colorString = $resultList[1];		string $colorStringArray[];		float $colors[];		tokenize $resultList[1] "," $colorStringArray;		for($c in $colorStringArray) {			$colors[size($colors)] = (float) $c;		}				if($mode == "new") {						string $objects[] = `ls -sl -l -o`;			// what tab does this button belong to			string $tabLayout = `tabLayout -q -st $aweCPTabLayout`;			aweCPNewPicker(1, $tabLayout, $newLabel, $colors, $objects);		}				if($mode == "edit") {									// edit the button			iconTextButton -e -l $newLabel -bgc $colors[0] $colors[1] $colors[2] $button;						// update objectSet name to reflect new label			string $pickerSet = aweCPGetPickerSet($button);			// write the new data into the set attributes			setAttr ($pickerSet + ".CP_Label") -type "string" $newLabel;			setAttr ($pickerSet + ".CP_Color") -type "float3" $colors[0] $colors[1] $colors[2];						// rename pickerSet			if(!`referenceQuery -inr $pickerSet`) {				string $newSetName = aweCPFormPickerSet($newLabel);				catchQuiet(`rename $pickerSet $newSetName`);			}		}	}}	global proc string aweCPGetLabelColor(string $field, string $palette) {	// retrieves label and color from PickerEdit layoutDialog		/*	//	RETURNS:	string "label:Color1,Color2,Color3"	//	//	DEPENDS:	aweCPMakeValidPickerLabel	*/		string $label = `textField -q -tx $field`;	float $color[] = `palettePort -q -rgb $palette`;		// build return string	string $return = "";	// default to 'Picker' if label was empty	if($label == "") 	$label = "Picker";	else $label = aweCPMakeValidPickerLabel($label);	$return += $label;	$return += ":";	$return += ($color[0] + "," + $color[1] + "," +  $color[2]);		return $return;}global proc aweCPEditDialogUI(string $label, string $color[]) {	// builds custom modal Dialog UI for Picker editing		/*	//	Called as the -ui flag from a layoutDialog command inside CPBtnDialog().	//	Expects a label string and a color array as input.	//	If we're creating a new Picker, $color should default to the values of 'default grey'.	//	//	DEPENDS:	aweCPGetLabelColor	*/		// while in the layoutDialog -ui command, the following line	// will set $form to the layout created by that command	$form = `setParent -q`;		$message = `text		-w 152		-l "Choose a label for this button"		BtnLabelText`;	$labelField = `textField		-w 152		-tx $label		BtnLabelField`;	$colorText = `text		-w 152		-l "Choose a color for this button"		BtnColorText`;	$colorPort = `palettePort		-h 38		-w 152		-dim 6 2		-td 1		-ced 0		-scc 1		BtnColorPort`;	$separator = `separator		-h 2		-hr 1		-w 150		-st "in"		BtnDialogSeparator`;	// create command to be evaluated to return textField value as $B1's command	$cmd1 = "`aweCPGetLabelColor \\\"BtnLabelField\\\" \\\"BtnColorPort\\\"`";	$cmd = ("layoutDialog -dis " +  $cmd1);	$cmd = ("eval(\""+$cmd+"\")");	$B1 = `button		-w 75		-l "OK"		-c $cmd		OKBtn`;	$B2 = `button		-w 75		-l "Cancel"		-c "layoutDialog -dis \"dismiss\""		CancelBtn`;		formLayout -e		-w 180 -h 170		// Message Text		-af	$message		"top"		12		-af	$message		"left"	12		// Label TextField		-af	$labelField	"left"	12		-ac	$labelField	"top"		6		$message		// Color Text		-af	$colorText	"left" 	12		-ac	$colorText	"top"		12	$labelField		// Color Port		-af	$colorPort	"left"	14		-ac $colorPort	"top"		8		$colorText		// Separator		-af	$separator	"left"	15		-ac $separator	"top"		8		$colorPort		// Buttons		-af	$B2				"bottom"	8		-af	$B1				"left"		12		-ac	$B2				"left"		6		$B1		-af	$B1				"bottom"	8	$form;		// set up color indexes for palettePort	//	// default grey	palettePort -e	-rgb 0 	0.9 0.9 0.9				$colorPort;	// light blue	palettePort -e	-rgb 1 	0.32 0.73 0.89 		$colorPort;	// light green	palettePort -e	-rgb 2 	0.62 0.797 0.162 	$colorPort;	// yellow	palettePort -e	-rgb 3 	0.95 0.9 0.0			$colorPort;	//  light red	palettePort -e	-rgb 4 	0.89 0.22 0.22		$colorPort;	// bright purple	palettePort -e	-rgb 5 	0.759 0.42 0.85		$colorPort;	// dark grey // SECOND ROW	palettePort -e	-rgb 6 	0.51 0.51 0.51		$colorPort;	// dark blue	palettePort -e	-rgb 7 	0.10 0.38 0.78		$colorPort;	// dark green	palettePort -e	-rgb 8 	0.27 0.53 0.00		$colorPort;	// yellowish orange	palettePort -e	-rgb 9 	0.87 0.51 0.08		$colorPort;	// dark red	palettePort -e	-rgb 10 	0.60 0.10 0.09	$colorPort;	// dark purple	palettePort -e	-rgb 11 	0.50 0.17 0.58 	$colorPort;		palettePort -e -r $colorPort;	// find the index of palettePort that matches	// the passed-in value of $color and select it	float $colorFloat[3];	for($c = 0; $c <= 2; $c++) {		$colorFloat[$c] = (float) $color[$c];	}	for($i = 0; $i<=11; $i++) {		palettePort -e -scc $i $colorPort;		float $iColor[] = `palettePort -q -rgb $colorPort`;		if( (`equivalentTol $colorFloat[0] $iColor[0] 0.01`) && (`equivalentTol $colorFloat[1] $iColor[1] 0.01`) && (`equivalentTol $colorFloat[2] $iColor[2] 0.01`) )			break;	}	}global proc aweCPResizeDock(){	// resizes UI to accomodate tab widths		/*	//	This procedure takes care of checking whether the Option to	//	automatically resize has been set.	//	Mininum width should be 100, but will automatically	//	expand to the width of the UI buttons layout	*/	global string $aweCPTabLayout;	global string $aweCPDockWidget;		// only if optionVar calls for it	if(`optionVar -q "aweCPDisplayResizeDock"`) {		// get all tab labels		$labels = `tabLayout -q -tl $aweCPTabLayout`;		// approximate width per character for Tahoma is 11		int $charWidth = 11;		int $dockWidth = 0;		for($label in $labels) {			int $length = size($label);			$dockWidth += $charWidth * $length;		}		if($dockWidth < 100) $dockWidth = 100;		// resize the dock		dockControl -e -w $dockWidth $aweCPDockWidget;	}}global proc aweCPReset() {	// resets the UI		/*	//	Deletes all existing tabs, Picker buttons, objectSets	//	and the dockControl and rebuilds the UI from scratch.	//	//	Prompts user whether we want to reset the UI or just the Pickers.	//	In case of UI, all Settings are reset to their default values as well.	//	//	DEPENDS:	aweCPDeleteAllPickers, aweCPInitPickers, aweCPBuildUI	*/		global string $aweCPDockWidget;	string $prompt = `confirmDialog		-t "aweCP: Reset"		-icn "warning"		-m "Do you wish to clear all Picker buttons and/or reset the UI?\n\nThis action is not undoable!"		-b "Reset UI" -b "Reset Pickers" -b "Reset All" -b "Cancel" 		-db "Reset UI" -cb "Cancel" -ds "Cancel"`;		if($prompt == "Cancel") {		return;	}	string $regEx = "^.* ";	string $action = substitute($regEx, $prompt, "");		string $resultString = "// aweCP: Reset ";	switch ($action) {		case "Pickers":			$resultString += "Pickers.\n";			break;		case "UI":			$resultString += "UI.\n";			break;		case "All":			$resultString += "Pickers and UI.\n";			break;	}		if( ($action == "Pickers") || ($action == "All") ) {		aweCPDeleteAllPickers;		aweCPInitPickers;	}		if( ($action == "UI") || ($action == "All") ) {				if(`windowPref -ex aweCPWindow`) {			windowPref -remove aweCPWindow;		}		deleteUI $aweCPDockWidget;				// reset default options		optionVar -iv "aweCPDockWidth" 100;		optionVar -iv "aweCPDockHeight" 400;		optionVar -iv "aweCPDockFloat" 0;		optionVar -sv "aweCPDockArea" "left";		optionVar -clearArray "aweCPDockPosition";		optionVar -iva "aweCPDockPosition" 50;		optionVar -iva "aweCPDockPosition" 130;				optionVar -iv "aweCPMMTabs" 1;		optionVar -iv "aweCPMMViewPanes" 1;		optionVar -iv "aweCPMMGraphEditor" 1;		optionVar -iv "aweCPMMOutliner" 0;		optionVar -iv "aweCPMMHypershade" 0;				optionVar -iv "aweCPDisplayResizeDock" 0;		optionVar -iv "aweCPDisplayShadedPickers" 1;		optionVar -iv "aweCPDisplayPrefix" 1;		optionVar -iv "aweCPDisplayTabLabels" 1;		optionVar -iv "aweCPHilitePickers" 1;		optionVar -iv "aweCPPickerKeyObjects" 1;		optionVar -iv "aweCPPickerKeyChannels" 0;				optionVar -sv "aweCPPrefixMode" "Hierarchy";				// rebuild UI		aweCPBuildUI;	}		print $resultString;}global proc aweCPClick(string $button) {	// select/key objects associated with Picker		/*	//	This is the procedure called when the user left-clicks a Picker.	//	Takes a Picker button control as input and derives associated 	//	objectList (via its objectSet) from it.	//	Depending on the modifier keys pressed, it selects or keys objects	//	associated with the Picker (uses prefix if modifier=alt).	//	//	DEPENDS:	aweCPGetPickerSet, aweCPPrefixHierarchy, aweCPPrefixNamespace, 	//	........	aweCPPrefixPrefix, aweCPFilterKeyObjects	*/    	// get the objects associated with this Picker	string $objectSet = aweCPGetPickerSet($button);	string $objectArray[] = `sets -q $objectSet`;		// error out if the Picker is devoid of objects	if(!size($objectArray)) {		print("aweCP Error: This Picker is empty. Add objects first!\n");		return;	}		// this string that will be passed to the final command as its argument	// we populate it later when checking modifiers	string $argObjects;	// get the modifier keys pressed while the Picker was clicked	// first bit (1) is shift, third bit (4) is ctrl, fourth bit (8) is alt.	int $modKey = `getModifiers`;	// shift toggles selection	int $isShift = $modKey % 2;	// alt prefixes objectList	int $isAlt = $modKey / 8 % 2;	// ctrl keys objectList	int $isCtrl = $modKey / 4 % 2;	// first order of business: prefix objectList if necessary, because	// this modifier (alt) can be used with any other modifier	if($isAlt) {		string $prefixMode = `optionMenu -q -v CPPrefixModeMenu`;		string $prefix = `textField -q -tx CPPrefixEdit`;		// we replace the objectArray with a prefixed objectArray				if($prefixMode == "Hierarchy") {					$objectArray = aweCPPrefixHierarchy($objectArray, $prefix);		}				else if($prefixMode == "Namespace") {						$objectArray = aweCPPrefixNamespace($objectArray, $prefix);		}				else if($prefixMode == "Prefix") {						string $currentPrefix = `textField -q -tx CPCurrentPrefixEdit`;			$objectArray = aweCPPrefixPrefix($objectArray, $currentPrefix, $prefix);		}	}	// the command as well as the errorMsg to be called;	// again, this depends on the modifiers (ctrl, shift)	string $cmd;	string $errorMsg;	// ctrl overrides behaviour to set a key, so we check this first	if($isCtrl) {		// filter the objectArray according to Set Key options		$objectArray = aweCPFilterKeyObjects($objectArray);		// we need to distinguish whether $objectArray is now empty or not; 		// if it is, we mustn't call setKeyframe() at all or else any 		// currently selected object will be keyed instead; in that case, simply call print(""),		// which will do nothing with the empty argument $argObjects.		if(size($objectArray)) {			$cmd = "setKeyframe ";		}		else {			$cmd = "print \"\"";		}		$errorMsg = "// aweCP Warning: There was an error setting keys on some objects. See Script Editor for details.\n";	}	// no Ctrl means we simply select the objects	else {		$cmd = "select ";		// shift toggles selection		if($isShift) {			$cmd += "-tgl ";		}		$errorMsg = "// aweCP Warning: There was an error selecting some objects. See Script Editor for details.\n";	}		// add objectList to the command	$argObjects = stringArrayToString($objectArray, " ");	$cmd += $argObjects;	// execute the command	// if selecting/keying an object fails, do so in a friendly manner	$error = catch(eval($cmd));	if( $error ) {		print $errorMsg;	}}global proc aweCPRemoveSelected(string $button) {	// removes selected object(s) from a particular Picker		/*	//	Takes a Picker button as input	//	Any objects on the active list will be removed from the objectSet of this Picker	//	Called from the popup menu	//	//	DEPENDS:	aweCPGetPickerSet, aweCPGetLabel	*/		string $selection[] = `ls -sl -l -o`;		if(size($selection)) {				string $pickerSet = aweCPGetPickerSet($button);		string $tabSet[] = `listSets -o $pickerSet`;		string $pickerLabel = aweCPGetLabel($pickerSet);		string $tabLabel = aweCPGetLabel($tabSet[0]);		int $removed;		for($o in $selection) {			if(`sets -isMember $pickerSet $o`) {				sets -e -remove $pickerSet $o;				$removed++;			}		}		string $returnString = ("// aweCP: Removed " + $removed + " objects from " + $tabLabel + "|" + $pickerLabel + "\n");		print $returnString;	}	else {		print "// aweCP Error: No objects selected!";	}}global proc aweCPAddSelected(string $button) {	// adds selected object(s) to a Picker		/*	//	Takes a Picker button as input	//	Any objects on the active list will be added to the objectSet of this Picker	//	Called from the popup menu	//	//	DEPENDS:	aweCPGetPickerSet, aweCPGetLabel	*/		string $selection[] = `ls -sl -l -o`;		if(size($selection)) {				string $pickerSet = aweCPGetPickerSet($button);		string $tabSet[] = `listSets -o $pickerSet`;		string $pickerLabel = aweCPGetLabel($pickerSet);		string $tabLabel = aweCPGetLabel($tabSet[0]);		int $added, $skipped = 0;		for($o in $selection) {			if(!`sets -isMember $pickerSet $o`) {				sets -e -add $pickerSet $o;				$added++;			}			else {				$skipped++;			}		}		string $returnString = ("// aweCP: Added " + $added + " object(s) to " + $tabLabel + "|" + $pickerLabel);		if($skipped)  $returnString += (", " + $skipped + " skipped\n");		else  $returnString += "\n";		print $returnString;	}	else {		print("// aweCP Error: No objects selected!\n");	}}global proc aweCPClearPicker(string $button){	// clears all objects from a Picker's objectList		/*	//	Takes a Picker button as input	//	Purges all objects from this Picker's objectSet, making it select nothing	//	//	DEPENDS:	aweCPGetPickerSet, aweCPGetLabel	*/		// get the objectSet	string $pickerSet = aweCPGetPickerSet($button);	if(`getAttr ($pickerSet + ".CP_Type")` == "picker") {		string $tabSet[] = `listSets -o $pickerSet`;		// get label		string $pickerLabel = aweCPGetLabel($pickerSet);		string $tabLabel = aweCPGetLabel($tabSet[0]);				// empty the objectSet associated with this picker		sets -clear $pickerSet;		print("// aweCP: Cleared all objects from " + $tabLabel + "|" + $pickerLabel + "\n");	}	else {		print("// aweCP Error: Given objectSet is not of expected type (picker)!\n");	}}global proc aweCPDeletePicker(string $button) {	// deletes a Picker button		/*	//	Deletes the button's parent layout and all controls within,	//	as well as the Picker's objectSet.	//	Called from the popup menu.	//	//	DEPENDS:	aweCPGetPickerSet, aweCPGetLabel, aweCPUpdateUIIndex	*/	string $pickerSet = aweCPGetPickerSet($button);		if(`referenceQuery -inr $pickerSet`) {		print("// aweCP Error: Can't delete a referenced Picker\n");	}		else {		string $label = `iconTextButton -q -l $button`;		string $prompt = `confirmDialog						-t "Confirm Delete Picker"						-icn "question"						-m ("Are you sure you want to delete " + $label)						-b "Yes" -b "No" -db "Yes" -cb "No" -ds "No"`;								if($prompt == "Yes") {						string $layout = `control -q -p $button`;			string $objectSet = aweCPGetPickerSet($button);			string $tabSet[] = `listSets -o $objectSet`;			string $tabLabel = aweCPGetLabel($tabSet[0]);				// remove objectSet from tabSet, THEN delete it;			// else tabSet gets deleted with it if its empty			sets -e -rm $tabSet[0] $objectSet;			delete $objectSet;			evalDeferred("deleteUI " + $layout);						// update the stored position of each Picker			evalDeferred("aweCPUpdateUIIndex");						print("// aweCP: Deleted Picker '" + $tabLabel + "|" + $label + "'\n");		}	}}global proc aweCPNewTab(string $tabLabel) {	// creates a new tab		/*	//	$tabLabel is just for providing a starting label into the dialog.	//	This provides a more convenient user experience in case this proc is	//	called repeatedly due to an invalid or non-unique label being entered;	//	The last label entered will already be in the textField	//	//	DEPENDS:	aweCPMakeValidTabLabel, aweCPIsTabUnique, aweCPFormTabSet, aweCPCreateTabSet	*/	global string $aweCPTabLayout;		$promptResult = `promptDialog		-t "New Tab"		-tx $tabLabel		-m "Enter label for new tab"		-b "Create Tab" -b "Cancel"		-db "Create Tab" -cb "Cancel" -ds "Cancel"`;		if($promptResult != "Cancel") {				string $label = `promptDialog -q -tx`;			// label must not be empty string		if($label == "") {						print "// aweCP Error: You must enter a label!\n";			aweCPNewTab("");		}		else {						// no two tab labels may be identical			$label = aweCPMakeValidTabLabel($label);			int $isUnique = `aweCPIsTabUnique($label)`;			if($isUnique) {				// make sure we have a valid UI name				string $labelUIString = `formValidObjectName $label`;				string $tabLayoutName = ("CP" + $labelUIString + "TabLayout");				columnLayout  					-rs 3 -adj 1					-p $aweCPTabLayout					$tabLayoutName;				tabLayout -e -tl $tabLayoutName $label $aweCPTabLayout;				// create an objectSet for this tab				string $setName = aweCPFormTabSet($label);				// get index, which is equal to the number of existing tabs				int $index = `layout -q -nch $aweCPTabLayout`;				// create the objectSet for this tab				aweCPCreateTabSet($setName, $label, $index);				// resize dock				evalDeferred("aweCPResizeDock");			}			else {				print "// aweCP Error: A Tab with that name already exists!\n";				aweCPNewTab($label);			}				}		}}global proc aweCPRenameTab(string $tabLabel){	// renames a tab		/*	//	See description of aweCPNewTab to understand why we 	//	provide a $tabLabel argument to this procecure	//	//	This procedure refuses to rename referenced Tabs!	//	//	DEPENDS:	aweCPGetTabSet, aweCPMakeValidTabLabel, aweCPIsTabUnique, aweCPFormTabSet	*/		global string $aweCPTabLayout;		// get current tab and label	string $tabUIName = `tabLayout -q -st $aweCPTabLayout`;		// check if this tab is referenced	$set = aweCPGetTabSet("layout", $tabUIName);		if(`referenceQuery -inr $set`) {		print("// aweCP Error: Can't rename a referenced tab\n");	}	// not a reference; proceed	else {				int $tab = `tabLayout -q -sti $aweCPTabLayout`;		string $labelArray[] = `tabLayout -q -tl $aweCPTabLayout`;		// tab indexes are 1 based, array index is n-1		/* this line is deprecated; see below */		// string $fullCurrentLabel = $labelArray[$tab - 1]; // 		string $currentLabel = $labelArray[$tab - 1];				/* This check isn't necessary anymore; */		/* Only references can have namespaces, and those can't be renamed. */		/*		// check if we have a namespace; if so, then strip it first,		// then re-apply it after; this ensures the user can't manually create one		string $namespace = match("^.*:", $fullCurrentLabel);		string $currentLabel = match("[^:]*$", $fullCurrentLabel);		*/				$promptResult = `promptDialog			-t "Tab label"			-m "Enter a label for this tab"			// use $tabLabel if provided, else use $currentLabel			-tx ( (size($tabLabel)) ? $tabLabel : $currentLabel)			-b "OK" -b "Cancel"			-db "OK" -cb "Cancel" -ds "Cancel"`;				if($promptResult == "OK") {			string $inputLabel = `promptDialog -q -tx`;			if($inputLabel == "") {				print("// aweCP Error: Label must not be an empty string!\n");				return;			}						string $label = aweCPMakeValidTabLabel(`promptDialog -q -tx`);			int $isUnique = `aweCPIsTabUnique($label)`;						// don't do anything if the label wasn't changed			if($label == $currentLabel) {				return;			}			if ($isUnique) {								string $newLabel = $label;				string $newTabUIName = ("CP" + formValidObjectName($newLabel) + "TabLayout");				tabLayout -e -tli $tab $newLabel $aweCPTabLayout;				renameUI $tabUIName $newTabUIName;				// set the new objectSet name				string $oldSetName = aweCPGetTabSet("label", $currentLabel);				setAttr ($oldSetName + ".CP_Label") -type "string" $newLabel;				string $newSetName = aweCPFormTabSet($newLabel);				rename $oldSetName $newSetName;								// resize dock				evalDeferred("aweCPResizeDock");								print ("// aweCP: Renamed Tab '" + $currentLabel + "' to '" + $newLabel + "'\n");							}			else {				print "// aweCP Error: A Tab with that name already exists!\n";				aweCPRenameTab($label);			}			}			}}global proc aweCPDeleteTab(){	// deletes a tab	/*	//	Checks to see whether this is the last remaining tab or	//	if this tab is referenced. 	//	If any of those conditions are true, the tab isn't deleted. 	//	Otherwise delete the tab UI, the tab objectSet and all its child sets.	//	//	DEPENDS:	aweCPGetTabSet, aweCPUpdateUIIndex, aweCPResizeDock	*/	global string $aweCPTabLayout;		// do not delete the last existing tab	int $numTabs = size(`tabLayout -q -ca $aweCPTabLayout`);	if($numTabs > 1) {				int $tabIndex = `tabLayout -q -sti $aweCPTabLayout`;		string $allTabLabels[] = `tabLayout -q -tl $aweCPTabLayout`;		string $tabLabel = $allTabLabels[$tabIndex - 1];				// check if this tab is referenced		string $set = aweCPGetTabSet("label", $tabLabel);		if(`referenceQuery -inr $set`) {			print("// aweCP Error: Can't delete a referenced tab\n");		}				else {					$promptResult = `confirmDialog				-t "Delete Tab"				-icn "question"				-m ("Are you sure you want to delete '" + $tabLabel + "'?")				-b "Yes" -b "Cancel"				-db "Yes" -cb "Cancel" -ds "Cancel"`;						if ($promptResult == "Yes") {								$tabLayout = `tabLayout -q -st $aweCPTabLayout`;				deleteUI $tabLayout;				// delete the objectSets associated with the tab's pickers, 				// then delete the tab objectSet				$tabSet = aweCPGetTabSet("label", $tabLabel);					string $pickerSets[] = `sets -q $tabSet`;				for($set in $pickerSets) {					delete $set;				}				// the tabSet may not exist anymore if all child sets were deleted, so catchQuiet				catchQuiet(`delete $tabSet`);								// update indices				evalDeferred("aweCPUpdateUIIndex");								// resize dock				evalDeferred("aweCPResizeDock");								print("// aweCP: Deleted Tab '" + $tabLabel + "'\n");			}		}	}	else {		print "// aweCP Error: You cannot delete the only existing tab!\n";	}}global proc aweCPMoveTabLeft(){	// move active tab left by 1 index	/*	//	Called from the UI button (<<)	//	Does nothing if the active tab is already the left-most tab.	//	//	DEPENDS:	aweCPUpdateUIIndex	*/		global string $aweCPTabLayout;		int $activeIndex = `tabLayout -q -sti $aweCPTabLayout`;	int $newIndex = $activeIndex - 1;	if($activeIndex > 1) {		tabLayout -e -mt $activeIndex $newIndex $aweCPTabLayout;		tabLayout -e -sti $newIndex $aweCPTabLayout;				// update indices		evalDeferred("aweCPUpdateUIIndex");	}}global proc aweCPMoveTabRight(){	// move active tab right by 1 index	/*	//	Called from the UI button (>>)	//	Does nothing if the active tab is already the right-most tab.	//	//	DEPENDS:	aweCPUpdateUIIndex	*/		global string $aweCPTabLayout;		int $activeIndex = `tabLayout -q -sti $aweCPTabLayout`;	int $numTabs = `tabLayout -q -nch $aweCPTabLayout`;	int $newIndex = $activeIndex + 1;	if($activeIndex < $numTabs) {		tabLayout -e -mt $activeIndex $newIndex $aweCPTabLayout;		tabLayout -e -sti $newIndex $aweCPTabLayout;				// update indices		evalDeferred("aweCPUpdateUIIndex");	}}global proc aweCPPreviousTab(){	// select previous tab index	/*	//	Implemented as a means to toggle through tabs	//	when tab labels are set to be hidden	*/		global string $aweCPTabLayout;		// get current index	int $index = `tabLayout -q -sti $aweCPTabLayout`;	if($index > 1) {		tabLayout -e -sti ($index - 1) $aweCPTabLayout;		// get tab label		string $tabLabels[] = `tabLayout -q -tl $aweCPTabLayout`;		int $newIndex = `tabLayout -q -sti $aweCPTabLayout`;		string $label = $tabLabels[$newIndex - 1];		print("// aweCP: Current Tab is now '" + $label + "'\n");	}}global proc aweCPNextTab(){	// select next tab index	/*	//	Implemented as a means to toggle through tabs	//	when tab labels are set to be hidden	*/		global string $aweCPTabLayout;		// get current index	int $index = `tabLayout -q -sti $aweCPTabLayout`;	int $numTabs = `tabLayout -q -nch $aweCPTabLayout`;	if($index < $numTabs) {		tabLayout -e -sti ($index + 1) $aweCPTabLayout;		// get tab label		string $tabLabels[] = `tabLayout -q -tl $aweCPTabLayout`;		int $newIndex = `tabLayout -q -sti $aweCPTabLayout`;		string $label = $tabLabels[$newIndex - 1];		print("// aweCP: Current Tab is now '" + $label + "'\n");	}}	global proc aweCPSavePickers() {	// saves out a collection of Pickers and Tabs		/*	//	Creates a clear-text .cpf file representing the scene's Picker configuration	//	First line contains tab label collection.	//	Following lines each form a picker button configuration (label, color, objectList etc.).	//	Picker's associated objects are stored as absolute DAG paths.	//	//	DEPENDS:	aweCPGetPickerSet, aweCPGetLabel, aweCPGetColor	*/		global string $aweCPTabLayout;		string $fileResult[] = `fileDialog2 		-cap "Save Custom Picker File" 		-fm 0 		-ff "Picker File (*.cpf)"		-sff "Picker File"		-okc "Save" -cc "Cancel"`;	if(size($fileResult)) {			string $file = $fileResult[0];				$f = `fopen $file "w"`;					if($f) {					// firstly, gather the tab info			string $tabLabels[] 	= `tabLayout -q -tl $aweCPTabLayout`;			string $tabLayouts[] 	= `layout -q -ca $aweCPTabLayout`;						// encode the first line, containing the tab info			string $tabString = stringArrayToString($tabLabels, ",");			fprint $f $tabString;			fprint $f "\n";			fflush $f;			// now, we loop over each tab...			for($t = 0; $t < size($tabLayouts); $t++) {				string $tabLayout = $tabLayouts[$t];				string $btnLayouts[] = `layout -q -ca $tabLayout`;				// ... and over each btnLayout within				for ($b in $btnLayouts) {										// form (unique) full paths to all following controls					string $btnLayout = ($tabLayout + "|" + $b);					string $tabLabel = $tabLabels[$t];					string $pickerSet = aweCPGetPickerSet($btnLayout + "|CPPickerBtn");					string $label = aweCPGetLabel($pickerSet);					float $colorFloatArray[] = aweCPGetColor($pickerSet);					string $objectList[] = `sets -q $pickerSet`;					string $objects = stringArrayToString($objectList, ",");										string $colorStringArray[];					int $i;					for($i = 0; $i <= 2; $i++) {						$colorStringArray[$i] = (string) $colorFloatArray[$i];					}					string $color = stringArrayToString($colorStringArray, ",");										string $encodedLine = ($tabLabel + "%" + $label + "%" + $color + "%"  + $objects);										fprint $f $encodedLine;					fprint $f "\n";					fflush $f;				}			}							print("// aweCP: Saved Pickers to " + $file + "\n");		}		else {			warning ("// aweCP Error: File could not be created: " + $file + "\n");		}					fclose $f;	}}global proc aweCPLoadPickers() {	// loads and parses contents of a .cpf file		/*	//	Calls a .CPF file from a loadDialog and parses it:	//	Creates the necessary objectSets and calls CPInitPickers()	//	to create the Tabs and Pickers	//	//	DEPENDS:	aweCPDeleteAllPickers, aweCPCreatePickerSet, aweCPGetLabel, aweCPCheckLabelNamespace, 	//	........	aweCPListTabSets, aweCPFormPickerSet, aweCPFormTabSet, aweCPResizeDock, aweCPInitPickers,	//	........	aweCPCreateTabSet, aweCPGetTabSet 	*/		global string $aweCPTabLayout;		// call the fileDialog	string $fileResult[] = `fileDialog2 			-cap "Load Custom Picker File" 			-ds 2			-fm 1 			-ff "Picker File (*.cpf)"			-sff "Picker File"			-okc "Load" -cc "Cancel"`;				// abort if user cancelled			if(size($fileResult) == 0) {		return;	}		// first, ask whether to append or replace	$promptResult = `confirmDialog					-t "Load Pickers"					-m "Do you wish to replace current Pickers \nor append loaded Pickers?"					-icn "question"					-b "Replace" -b "Append" -b "Cancel"					-db "Replace" -cb "Cancel" -ds "Cancel"`;						if($promptResult != "Cancel") {					$f = `fopen $fileResult[0] "r"`;				if($f) {						if($promptResult == "Replace") {				aweCPDeleteAllPickers;			}						// get existing tabLabels			string $existingTabLabels[];			string $existingTabSets[] = aweCPListTabSets("all");			for($et in $existingTabSets) {				$existingTabLabels[size($existingTabLabels)] = aweCPGetLabel($et);			}						string $tabSetArray[], $tabLabelArray[], $missingObjects[], $brokenPickers[], $brokenTabs[];			int $lineNum = 0;			int $numTabs = `tabLayout -q -nch $aweCPTabLayout`;				// loop through each line until end of file			while(!feof($f)) {				$lineNum++;				$line = `fgetline $f`;								// there is one additional, empty line at end of file				// due to "\n" being printed last; ignore it				if(size($line)) {									// first, parse tabs on first line					if($lineNum == 1) {												// strip "\n" from the line						 string $strippedString = `substring $line 1 (size($line) - 1)`;						 string $tabs[];						 tokenize $strippedString "," $tabs;							// now, let's create the tab objectSets						for ($t = 0; $t < size($tabs); $t++) {														// check for namespace validity							string $label = aweCPCheckLabelNamespace($tabs[$t]);														// apply a temporary index: existingTabs + $t; 							// this will be updated by InitPickers() at the end of this procedure							int $index = $t + $numTabs + 1;							string $tabSetName = aweCPFormTabSet($label);							// do not set the label to be the clean label yet, else pickers can't 							// find out which tab they belong to later;							$tabSet = aweCPCreateTabSet($tabSetName, $tabs[$t], $index);														// add this set to the array; 							// $tabLabelArray holds the original label, while							// $tabSetArray holds the actual objectSet name with the same index							$tabLabelArray[size($tabLabelArray)] = $label;							$tabSetArray[size($tabSetArray)] = $tabSet;						}												// finally, resize dock to show as many tabs as possible						aweCPResizeDock;					}										// now, parse the remaining lines (one line per Picker)					else {												// get individual data from this line						string $buffer[];						tokenize $line "%" $buffer;						string $tabLabel = $buffer[0];						string $pickerLabel = $buffer[1];						string $colorString = $buffer[2];						// form color floats						string $colorStringArray[];						tokenize $colorString "," $colorStringArray;						float $colors[3];						$colors[0] = (float) $colorStringArray[0];						$colors[1] = (float) $colorStringArray[1];						$colors[2] = (float) $colorStringArray[2];						// strip "\n" from the last item						string $objectString = `substring $buffer[3] 1 (size($buffer[3]) - 1)`;												// identify the tab objectSet this picker belongs to						string $tabSet = aweCPGetTabSet("label", $tabLabel);												// create the objectSet for this picker						string $pSetName = aweCPFormPickerSet($pickerLabel);						// use lineNumber as temporary position ID; this means that a Picker's						// position in the tab is defined by the lineNumber it appears on in the CPF file						$pickerSet = aweCPCreatePickerSet($pSetName, $pickerLabel, $colors, $lineNum);						sets -e -add $tabSet $pickerSet;												// add objectList to this set; we do this one object at a time to catch non-existing objects						string $objectArray[] = stringToStringArray($objectString, ",");						for($object in $objectArray) {							if(objExists($object)) {								sets -e -add $pickerSet $object;							}							else {								$missingObjects[size($missingObjects)] = $object;								$brokenTabs[size($brokenTabs)] = $tabLabel;								$brokenPickers[size($brokenPickers)] = $pickerLabel;							}						}															} // if not first line									} // if not empty line							} // while not EOF									// we are done parsing the file						// ensure uniqueness of all tabs we just created			for($tab in $tabSetArray) {				string $originalLabel = aweCPGetLabel($tab);				string $label = aweCPCheckLabelNamespace($originalLabel);				string $uniqueLabel = $label;				int $x = 1;				while(stringArrayContains($uniqueLabel, $existingTabLabels)) {					$uniqueLabel = $label + $x;					$x++;				}				setAttr ($tab + ".CP_Label") -type "string" $uniqueLabel;				$existingTabLabels[size($existingTabLabels)] = $uniqueLabel;								// update tabSet name to reflect label				string $newSetName = aweCPFormTabSet($uniqueLabel);				rename $tab $newSetName;								// update all occurences of original label in $brokenTabs				for($l = 0; $l < size($brokenTabs); $l++) {					if($brokenTabs[$l] == $originalLabel) {						$brokenTabs[$l] = $uniqueLabel;					}				}			}						// if objects are missing, inform the user			if(size($missingObjects)) {				print("//\n");				print("// aweCP Error: Object(s) not found\n");				print("/ ------------------\n");				print("/ <Object> in <Tab|Picker>\n");				print("/ ------------------\n");				for($i = 0; $i < size($missingObjects); $i++) {					print("/ " + $missingObjects[$i] + " in " + $brokenTabs[$i] + "|" + $brokenPickers[$i] + "\n");				}				print("/ ------------------\n");				print("// aweCP Warning: One more more objects not found. See Script Editor for details.\n");			}						// call CPInitPickers() to build the UI for the new Pickers			aweCPInitPickers;		}		else {			warning ("Error reading file " + $fileResult[0]);		}				fclose $f;	}}global proc aweCPBuildMM() {	// creates the MarkingMenu for Pickers		/*	//	Builds the MarkingMenu and populates it on the fly with the current list 	//	of Pickers; depending on Options->MarkingMenu creates a single list for 	//	the active tab or a list of subMenus for each existing tab.	//	//	Use this function as the script for a Hotkey (after checking if it exists)	//	//	DEPENDS:	aweCPFindPopupParent	*/		global string $aweCPTabLayout;		if(`popupMenu -q -ex "aweCPMarkingMenu"`) {				deleteUI "aweCPMarkingMenu";		}		// first, find the panel parent	string $parentPanel[] = `aweCPFindPopupParent`;	// now, figure out which panels are allowed	// as defined in the Options menu	string $allowedTypeArray[];	int $cbItem;	// ... viewPanes/modelPanels	$cbItem = `menuItem -q -cb CPMMinViewportItem`;	if($cbItem)	$allowedTypeArray[size($allowedTypeArray)] = "modelPanel";	// ... graphEditor	$cbItem = `menuItem -q -cb CPMMinGraphEditorItem`;	if($cbItem)	$allowedTypeArray[size($allowedTypeArray)] = "graphEditor";	// ... Outliner	$cbItem = `menuItem -q -cb CPMMinOutlinerItem`;	if($cbItem)	$allowedTypeArray[size($allowedTypeArray)] = "outlinerPanel";	// ... hyperShade	$cbItem = `menuItem -q -cb CPMMinHypershadeItem`;	if($cbItem)	$allowedTypeArray[size($allowedTypeArray)] = "hyperShadePanel";		// now that we have an array of allowed types, see if $parentPanel	// is among them (if not, don't build the MM)	if(`stringArrayContains $parentPanel[1] $allowedTypeArray`) {					// create markingmenu		$menu = `popupMenu			-p $parentPanel[0]			-mm 1			-b 1			"aweCPMarkingMenu"`;				// int id used for menuItem naming (internal UI name)		int $id = 0;				// we need to determine which tab contents to display		// 0 means current tab, 1 means all tabs		// defaults to 0 unless there is more than one tab		// AND the Settings are set to ALL tabs		int $mmSetting = 0;		int $numTabs = size(`layout -q -ca $aweCPTabLayout`);		if ($numTabs > 1) {			if (`menuItem -q -rb CPMMTabSettingsRB2`) {				$mmSetting = 1;			}		}				string $titleItemLabel;				if (!$mmSetting) {			int $selectedTab = `tabLayout -q -sti $aweCPTabLayout`;			string $allTabLabels[] = `tabLayout -q -tl $aweCPTabLayout`;			$titleItemLabel = $allTabLabels[$selectedTab - 1];		}		else {			$titleItemLabel = "PICKERS";		}				menuItem			-p $menu			-en 0			-l $titleItemLabel			-bld 1			-itl 1			"CPMMItem_Title";		menuItem			-p $menu			-divider 1			"CPMMDivider";					// show only current tab		if ($mmSetting == 0) {					string $tabLayout = `tabLayout -q -st $aweCPTabLayout`;				// create list of pickers iff any exist			string $btnLayouts[] = `layout -q -ca $tabLayout`;			if(`size $btnLayouts`) {				for($b in $btnLayouts) {					// we need a fullPath to each layout					string $buttonLayout = ($tabLayout + "|" + $b);					string $elements[] = `layout -q -ca $b`;					string $button = ($buttonLayout + "|" +  $elements[1]);										// copy the button's label and command and apply to this menuItem					string $label = `iconTextButton -q -l $button`;					string $cmd = `iconTextButton -q -c $button`;										menuItem						-p $menu						-l $label						-c $cmd						-ecr 0					("CPMMItem_"+$id);								$id++;				}			}			else {				menuItem					-l "-- None --"					-en 0					-p $menu					-itl 1				"CPMMItem_None";			}			// add submenu to switch active tabs unless there only is one tab			if($numTabs > 1) {				// divider				menuItem					-divider 1					-p $menu				"CPMMDivider2";				string $tabMenu = `menuItem					-sm 1					-l "Change active tab"					-p $menu										-itl 1				"CPMMItem_SwitchTabs"`;				// gather tabs into menuItems				string $tabLabels[] = `tabLayout -q -tl $aweCPTabLayout`;				for($t = 0; $t < size($tabLabels); $t++) {					menuItem						-p $tabMenu						-l $tabLabels[$t]						-c ("tabLayout -e -sti " + ($t+1) + " " + $aweCPTabLayout + "; evalDeferred(\"aweCPBuildMM\");")					("CPMMTabSwitchItem_" + $t);				}			}		}				// show all tabs		if ($mmSetting == 1) {			// loop through all tab layouts			string $tabArray[] = `layout -q -ca $aweCPTabLayout`;			string $labelArray[] = `tabLayout -q -tl $aweCPTabLayout`;			for($i = 0; $i < $numTabs; $i++) {								string $tabLayout = $tabArray[$i];				string $tabLabel = $labelArray[$i];					string $subMenu = `menuItem					-p $menu					-sm 1					-l $tabLabel				("aweCPMMSubMenu" + $i)`;								string $btnLayouts[] = `layout -q -ca $tabLayout`;				if(`size $btnLayouts`) {					for($b in $btnLayouts) {												string $buttonLayout = ($tabLayout + "|" + $b);						string $elements[] = `layout -q -ca $buttonLayout`;						string $button = ($buttonLayout + "|" + $elements[1]);												string $label = `iconTextButton -q -l $button`;						string $cmd = `iconTextButton -q -c $button`;												menuItem							-p $subMenu							-l $label							-c $cmd							-ecr 0						("CPMMItem_"+$id);										$id++;					}				}				else {					menuItem						-l "-- None --"						-en 0						-p $subMenu						-itl 1					"CPMMItem_None";				}			}		}	}}global proc aweCPDeleteMM() {	// destroys the MarkingMenu		/*	// Use this function as the script for a -release state Hotkey,	// after checking if it exists.	*/	if(`popupMenu -q -ex "aweCPMarkingMenu"`)		deleteUI "aweCPMarkingMenu";}global proc aweCPShowHelp(){	// show the help window		if(`windowPref -ex aweCPHelpWindow`) windowPref -remove aweCPHelpWindow;	if(`window -q -ex aweCPHelpWindow`) deleteUI aweCPHelpWindow;		string $helpText;	$helpText += "// OVERVIEW\n\n";	$helpText += "Create a shelfbutton for this script with the MEL command:\naweControlPicker();\n\n";	$helpText += "Create Pickers for selected objects by clicking the PCKR(+) button. Labels must not contain: Space, Comma, _, :, %.\n";	$helpText += "Edit pickers by right-clicking them:\nAdd Selection: Adds selected objects to this Picker\nRemove Selection: Removes selected objects from this Picker";	$helpText += "\nThe TABS button menu lets you add, rename or delete Tabs.\n";	$helpText += "\n// OPTIONS\n";	$helpText += "\nSave Pickers:\nSave current configuration to external file. Stores absolute names of objects for each Picker.\n";	$helpText += "\nLoad Pickers:\nLoad configuration from external file. Only works if stored Picker objects are found at same DAG path within scene.\n";	$helpText += "\nRe-Initialize Pickers:\nScan scene for Picker configuration and create them; run this after importing files with Pickers in them.\n";	$helpText += "\nReset:\nDeletes all Pickers and re-builds the UI. To Undo, hit Z and then choose Options > Re-Initialize Pickers (not 100% secure)\n";	$helpText += "\n// MARKING MENU\n";	$helpText += "\nShow only current tab:\nThe MarkingMenu will only display the contents of the currently active Tab.\n";	$helpText += "\nShow all tabs:\nThe MarkingMenu will display submenus for every tab.\n";	$helpText += "\nShow in...:\nSelect in which panels the MarkingMenu can be accessed.\n";	$helpText += "\nTo access the MarkingMenu:\nCreate a hotkey under Window>Settings and Preferences>Hotkey Editor\n";	$helpText += "Add this command for the Direction:Press state:\nif(`exists aweCPBuildMM`) aweCPBuildMM;\n";	$helpText += "Add this command for the Direction:Release state:\nif(`exists aweCPDeleteMM`) aweCPDeleteMM;\n";	$helpText += "\nMarkingMenu is only available after running the script!";		$window = `window -w 300 -rtf 1 -t "aweControlPicker - Help" -tlb 1 -s 0 aweCPHelpWindow`;	columnLayout -adj 1 -rs 1;		scrollField -ed 0 -w 300 -h 150 -ww 1 -fn "smallPlainLabelFont" -text $helpText;		frameLayout -bs "etchedIn" -l "Modifier Keys Overview" -li 10 -mh 4 -mw 4 -cl 0 -cll 1 -bgc .07 .12 .2;			columnLayout -adj 1 -rs 4;				rowLayout -cat 2 "left" 5 -nc 2 -adj 2 -cw2 130 160 -cl2 "left" "left";					text -w 130 -h 16 -rs 0 -l " LMB" -fn "smallPlainLabelFont";					text -w 160 -h 16 -rs 0 -l " Select picker objects	";					setParent..;				rowLayout -cat 2 "left" 5 -nc 2 -adj 2 -cw2 130 160 -cl2 "left" "left";					text -w 130 -h 16 -bgc .23 .23 .23 -rs 0 -l " LMB + SHIFT" -fn "smallPlainLabelFont";					text -w 160 -h 16 -bgc .23 .23 .23 -rs 0 -l " Toggle picker objects' selection";					setParent..;				rowLayout -cat 2 "left" 5 -nc 2 -adj 2 -cw2 130 160 -cl2 "left" "left";					text -w 130 -h 16 -rs 0 -l " LMB + CTRL" -fn "smallPlainLabelFont";					text -w 160 -h 16 -rs 0 -l " Set Keyframe for picker objects";					setParent..;				rowLayout -cat 2 "left" 5 -nc 2 -adj 2 -cw2 130 160 -cl2 "left" "left";					text -w 130 -h 16 -bgc .23 .23 .23 -rs 0 -l " LMB + ALT" -fn "smallPlainLabelFont";					text -w 160 -h 16 -bgc .23 .23 .23 -rs 0 -l " Use Prefix for selection";					setParent..;				rowLayout -cat 2 "left" 5 -nc 2 -adj 2 -cw2 130 160 -cl2 "left" "left";					text -w 130 -h 16 -rs 0 -l " MMB Drag" -fn "smallPlainLabelFont";					text -w 160 -h 16 -rs 0 -l " Move Picker";					setParent..;					rowLayout -cat 2 "left" 5 -nc 2 -adj 2 -cw2 130 160 -cl2 "left" "left";					text -w 130 -h 16 -bgc .23 .23 .23 -rs 0 -l " MMB + SHIFT Drag" -fn "smallPlainLabelFont";					text -w 160 -h 16 -bgc .23 .23 .23 -rs 0 -l " Merge Pickers";					setParent..;				rowLayout -cat 2 "left" 5 -nc 2 -adj 2 -cw2 130 160 -cl2 "left" "left";					text -w 130 -h 16 -rs 0 -l " MMB + CTRL Drag" -fn "smallPlainLabelFont";					text -w 160 -h 16 -rs 0 -l " Combine into new Picker";					setParent..;				rowLayout -cat 2 "left" 5 -nc 2 -adj 2 -cw2 130 160 -cl2 "left" "left";					text -w 130 -h 16 -bgc .23 .23 .23 -rs 0 -l " MMB + SHIFT + CTRL Drag" -fn "smallPlainLabelFont";					text -w 160 -h 16 -bgc .23 .23 .23 -rs 0 -l " Swap Picker Position";					setParent..;				setParent..;			setParent..;			rowLayout -nc 2 -adj 2;			string $urlCmd = "showHelp -a \"http://nyro.de/scripts/aweControlPicker\"";			button -w 160 -l "View Online Documentation" -bgc .22 .22 .22 -c $urlCmd;			button -l "Close" -bgc .22 .22 .22 -c ("evalDeferred(\"deleteUI "+$window+"\")");				showWindow $window;}global proc aweCPToggleKeySettings(int $state) {	// toggles behaviour for setting keys on Pickers	// toggle the state	optionVar -iv "aweCPPickerKeyObjects" $state;	// enable/disable dependent checkbox	menuItem -e -en (!$state) CPPickersSettingsChannelItem;}global proc aweCPTogglePrefixMode(string $mode){	// toggles the Prefix UI to match the current mode		/*	//	Called from the Prefix optionMenu's -changeCommand flag,	//	where $mode is substituted with the currently selected item	*/		optionVar -sv "aweCPPrefixMode" $mode;		if( ($mode == "Hierarchy") || ($mode == "Namespace") ) {		textField -e -vis 0 CPCurrentPrefixEdit;	}	if( $mode == "Prefix" ) {		textField -e -vis 1 CPCurrentPrefixEdit;	}	}global proc aweCPTogglePrefixEditor(){	// toggles display of the Prefix box in the UI		// get current state	int $display = `optionVar -q "aweCPDisplayPrefix"`;	// reverse current state and apply	optionVar -iv "aweCPDisplayPrefix" (!$display);	menuItem -e -cb (!$display) CPDisplayPrefixItem;	layout -e -vis (!$display) CPPrefixLayout;}global proc aweCPToggleTabLabels(){	// toggles display of Tab labels	/*	//	Hides or shows tab labels;	//	Depending on the setting, we also need to display the correct	//	set of buttons (move or select)	.	*/		global string $aweCPTabLayout;		// get current state	int $display = `optionVar -q "aweCPDisplayTabLabels"`;	// revers current state and apply	optionVar -iv "aweCPDisplayTabLabels" (!$display);	menuItem -e -cb (!$display) CPDisplayTabLabelsItem;	tabLayout -e -tv (!$display) $aweCPTabLayout;	// replace buttons accordingly	button -e -vis (!$display) CPMoveTabLeftBtn;	button -e -vis (!$display) CPMoveTabRightBtn;	text -e -vis (!$display) CPMoveTabText;	button -e -vis $display CPSelectPrevTabBtn;	button -e -vis $display CPSelectNextTabBtn;	text -e -vis $display CPSelectTabText;		// ResizeDock should always be off if no tabs are visible	// if we're toggling OFF: disable the menuItem and resize-optionVar	if($display) {		optionVar -iv "aweCPDisplayResizeDock" 0;		menuItem -e -en 0 CPDisplayResizeDockItem;	}	// if we're toggling ON: enable the menuItem and set optionVar to previous state	else {		menuItem -e -en 1 CPDisplayResizeDockItem;		int $isResize = `menuItem -q -cb CPDisplayResizeDockItem`;		optionVar -iv "aweCPDisplayResizeDock" $isResize;	}}global proc aweCPToggleShadedPickers(){	// toggles shaded or flat display of Pickers	/*	//	Uses InitPickers() to redraw all Pickers;	//	This isn't even bruteforce, this is full-on Juggernaught mode,	//	though tests show update time is virtually instant	//	//	DEPENDS:	aweCPInitPickers	*/		// get current state	int $shaded = `optionVar -q "aweCPDisplayShadedPickers"`;	// revers current state	optionVar -iv "aweCPDisplayShadedPickers" (!$shaded);	menuItem -e -cb (!$shaded) CPDisplayShadedPickersItem;	// redraw Pickers	aweCPInitPickers;}global proc aweCPToggleResizeDock(){	// toggles automatic resizing of UI for Tabs		// get current state	int $resize = `optionVar -q "aweCPDisplayResizeDock"`;	// toggle	optionVar -iv "aweCPDisplayResizeDock" (!$resize);	menuItem -e -cb (!$resize) CPDisplayResizeDockItem;}global proc aweCPTogglePickerHilite(){	// toggles hiliting of Pickers	/*	//	Creates or kills the scriptJob responsible for hilighting Pickers	//	//	DEPENDS:	aweCPClearHilite, aweCPUpdateHilite	*/		global int $aweCPHiliteJob;		// get current state	int $hilite = `optionVar -q "aweCPHilitePickers"`;	// toggle	optionVar -iv "aweCPHilitePickers" (!$hilite);	menuItem -e -cb (!$hilite) CPDisplayHilitePickersItem;		// delete the scriptJob if it exists	if($hilite) {		if(`scriptJob -ex $aweCPHiliteJob`) {			scriptJob -kill $aweCPHiliteJob;		}		// clear highlights when this feature is toggled off		aweCPClearHilite;	}	// create it if it doesn't exist	else {		if(!`scriptJob -ex $aweCPHiliteJob`) {			$aweCPHiliteJob = `scriptJob -p "aweCPDockWidget" -e "SelectionChanged" "aweCPUpdateHilite()"`;		}	}}				global proc aweCPUpdateHilite(){	// hilites Pickers that have active objects		/*	//	Lists all sets connected to any of the selected nodes and hilights the matching PickerLayouts	//	The initial isObscured check is merely an optimization effort (don't need to update if UI invisible)	//	//	Call this procedure from a scriptJob "selectionChange" event	*/		// exit immediately if UI invisible	global string $aweCPTabLayout;	if(`layout -q -io $aweCPTabLayout`) {		return;	}		aweCPClearHilite;		string $selection[] = `ls -sl -dag`;	if(size($selection)) {		string $connectedSets[] = `listConnections -type "objectSet" $selection`;		string $sets[] = stringArrayRemoveDuplicates($connectedSets);				for($set in $sets) {			if(	(attributeExists("CP_Type", $set)) && (aweCPGetType($set) == "picker") )  {				// catch quiet to catch Pickers created with earlier versions of the script				// that might not have the CP_UI attribute on their set				if(!catchQuiet($layout = `getAttr ($set + ".CP_UI")`))					layout -e -bgc .7 .7 .7 $layout;			}		}	}}global proc aweCPStoreUIPrefs(){	// stores optionVar for UI data		/*	//	This proc stores all UI data that is meant to be persistent between	//	sessions into the respective optionVars before saving them to disk.	//	//	This is mainly designed to be able to store optionVars during	//	a scriptJob "quitApplication" event (as such a job triggers *after* 	//	Maya makes a call to savePrefs(), so we have to save manually).	*/		global string $aweCPDockWidget;	global string $aweCPWindow;		string $masterLayout = ($aweCPWindow + "|CPMasterLayout");		// we use the width of the masterLayout, for some reason it's	// more reliable than directly querying the dockControl	optionVar -iv "aweCPDockWidth" `layout -q -w $masterLayout`;	optionVar -iv "aweCPDockHeight" `layout -q -h $masterLayout`;		int $isFloating = `dockControl -q -fl $aweCPDockWidget`;	optionVar -iv "aweCPDockFloat" $isFloating;		// the dockWidget's position is only relevant if floating, 	// otherwise we can't access it via window command	if($isFloating) {		// first clear existing values		optionVar -clearArray "aweCPDockPosition";		// store position as array [left, top]		optionVar -iva "aweCPDockPosition" `window -q -leftEdge $aweCPDockWidget`;		optionVar -iva "aweCPDockPosition" `window -q -topEdge $aweCPDockWidget`;	}	// only set dockArea if docked	else {		optionVar -sv "aweCPDockArea" `dockControl -q -a $aweCPDockWidget`;	}		// done setting optionVars; save them to disk	print("// aweCP: Saving UI Preferences\n");	savePrefs -general;}global proc aweCPDockWindow(){	// docks the DockWidget	/*	//	Implemented as a global function in case the the UI	//	is 'lost', e.g. after having it sit on a second monitor	//	and subsequently deactivating that monitor.	*/		global string $aweCPDockWidget;		if(`control -q -ex $aweCPDockWidget`) {		dockControl -e -fl 0 -vis 1 -raise $aweCPDockWidget;	}	else {		print("// aweCP Error: aweControlPicker window not found.\n");	}}global proc aweCPDebugMode(int $enable){	// toggles echoing of aweCP commands to scriptEditor	/*	//	Only effective if 'echo: all' is enabled in the scriptEditor	*/	string $filters[] = `commandEcho -q -filter`;	if(!$enable) {		$filters[size($filters)] = "aweCP";		commandEcho -filter $filters;	}	if($enable) {		string $noCPFilters[] = stringArrayRemove({"aweCP"}, $filters);		commandEcho -filter $filters;	}}// #################################//// -----------		UI Callbacks//// First local procs for various drop scenarios// Then global callback functions// #################################proc aweCPMergePickers(string $source, string $targetLayout) {	// merge one Picker with another		/*	//	When dragging from PckrA to PckrB, PckrA is deleted	//	after the contents of its objectSet are copied to	//	PckrB's objectSet.	*/		string $target = ($targetLayout + "|CPPickerBtn");		if($source != $target) {				// get the object lists for both source and target		string $sourceSet = aweCPGetPickerSet($source);		string $targetSet = aweCPGetPickerSet($target);				// check if pickers are referenced		if(`referenceQuery -inr $sourceSet`) {			print("// aweCP Error: Can't merge a referenced Picker\n");		}				else {			string $srcLabel = `iconTextButton -q -l $source`;			string $targetLabel = `iconTextButton -q -l $target`;			string $srcLayout = `control -q -p $source`;						$prompt = `confirmDialog				-t "Merge Pickers"				-icn "warning"				-m ("Are you sure you wish to merge " + $srcLabel + " into " + $targetLabel + "?\n\n" + $srcLabel + " will be deleted!")				-b "Yes" -b "Cancel" -cb "Cancel" -db "Yes" -ds "Cancel"`;						if($prompt == "Yes") {								// get a list of objects in SOURCE that are not in TARGET				// and add them to TARGET				string $subObjects[] = `sets -sub $sourceSet $targetSet`;				if(size($subObjects)) {					sets -add $targetSet $subObjects;					print("// aweCP: Merged " + size($subObjects) + " object(s) into " + $targetLabel + "\n");				}				else {					print("// aweCP: Merged, but no objects overlapped\n");				}								// remove sourceSet from tabSet, THEN delete it;				// else tabSet gets deleted with it if it's empty				string $tabSet[] = `listSets -o $sourceSet`;				sets -e -rm $tabSet[0] $sourceSet;				delete $sourceSet;				// done merging, delete the source layout				evalDeferred("deleteUI "+ $srcLayout);								// update the stored position of each Picker; do it deferred so it definitely				// happens after the $srcLayout was deleted				evalDeferred("aweCPUpdateUIIndex");			}		}	}	else {		print "// aweCP: This script is not Buddhist. A picker can not become One with itself!\n";	}}proc aweCPCombinePickers(string $pickerA, string $layoutB) {	// combine two Pickers into a new one		/*	//	Dragging PckrA on to PckrB creates a new PckrC	//	which selects the objects of both Pckrs.	//	PckrC's color is inherited from PckrA	*/		global string $aweCPTabLayout;	string $pickerB = ($layoutB + "|CPPickerBtn");		if($pickerA != $pickerB) {				string $objectSetA = aweCPGetPickerSet($pickerA);		string $objectSetB = aweCPGetPickerSet($pickerB);				string $objectsAB[] = `sets -union $objectSetA $objectSetB`;				string $newLabel = (aweCPGetLabel($objectSetA) + " " + aweCPGetLabel($objectSetB));		float $colors[] = aweCPGetColor($objectSetA);		string $tabLayout = `tabLayout -q -st $aweCPTabLayout`;		aweCPNewPicker(1, $tabLayout, $newLabel, $colors, $objectsAB);				print("// aweCP: Created new Picker '" + $newLabel + "'\n");	}	else {		print "// aweCP Error: You can't clone a Picker!\n";	}}proc aweCPMovePicker(string $dragCtrl, string $dropCtrl, int $y){	// move a Picker to a new location		/*	//	Dragging dragCtrl onto dropCtrl will insert it either	//	before or after dropCtrl, depending on the dropLocation $y	//	We do this by moving all btnLayouts into a temp Layout, then	//	reparenting them to the tabLayout one by one in the same order;	//	the exception is the $drop button; when reparenting this, we simultaneously	//	reparent the $drag button (either before or after, depending on $y)	//	//	Note that we're using the shortNames of our UI elements and constructing our	//	own fullPathNames so we can be sure that	//		a) we're referring to the right UI (i.e. in the correct tab) and	//		b) we can refer to that same UI once we've parented it to a temp layout, at	//		which point it's original FPN ($dragCtrl) will be invalid	//	//	$dropCtrl is assumed to be a layout	*/		string $dropBtn = ($dropCtrl + "|CPPickerBtn");	if($dragCtrl == $dropBtn) {		return;	}	// get parent Layouts	string $dragParent = `control -q -p $dragCtrl`;	// dropCtrl is the layout, since it has the dropCallBack to support OSX	string $dropParent = $dropCtrl;	// get the tabLayout	string $tabLayout = `layout -q -p $dragParent`;	// get short names for the drag and drop layouts	string $drag = match("[^|]*$", $dragParent);	string $drop = match("[^|]*$", $dropParent);	// get all button layouts	string $btnLayouts[] = `layout -q -ca $tabLayout`;	// create temp Layouts	string $tempAllLayout = `columnLayout -m 0 -p CPMasterLayout`;	string $tempDragLayout = `columnLayout -m 0 -p CPMasterLayout`;		// move all layouts into their tempLayout	// they will remain in the same order they existed originally	for($btn in $btnLayouts) {		// reconstruct a fullPathName for the current tab|btnLayout		string $fpnBtn = ($tabLayout + "|" + $btn);		string $fpnDrag = ($tabLayout + "|" + $drag);		if($fpnBtn != $fpnDrag) 			layout -e -p $tempAllLayout $fpnBtn;		else 			layout -e -p $tempDragLayout $fpnBtn;	}		clear $btnLayouts;		// now move them all back until we're dealing with the dropLayout;	// in this case, decide in what order to insert the dragLayout.	$btnLayouts = `layout -q -ca $tempAllLayout`;	for($btn in $btnLayouts) {		// reconstruct a fullPathName for the current tempLayout|btnLayout		string $fpnBtn = ($tempAllLayout + "|" + $btn);		string $fpnDrop = ($tempAllLayout + "|" + $drop);		string $fpnDrag = ($tempDragLayout + "|" + $drag);		// if this * is not * the dropBtn, we reparent it to the tabLayout		if($fpnBtn != $fpnDrop) {			layout -e -p $tabLayout $fpnBtn;		}		// if this * is * the dropBtn, we come to a crossroads...		else {			// now we decide, based on $y dropLocation, whether to insert $drag before or after			if($y <= 8) {				// insert before: first dragCtrl, then dropCtrl				layout -e -p $tabLayout $fpnDrag;				layout -e -p $tabLayout $fpnDrop;			}			else {				// insert after: first dropCtrl, then dragCtrl				layout -e -p $tabLayout $fpnDrop;				layout -e -p $tabLayout $fpnDrag;			}		}	}		// Done! Now delete the tempLayouts and update stored position	deleteUI $tempAllLayout;	deleteUI $tempDragLayout;	evalDeferred("aweCPUpdateUIIndex");			}		global proc string[] aweCPBtnDragCB(string $dragControl, int $x, int $y, int $mods) {	// global DragCallBack for Picker Buttons		/*	//	Modifier keys define behaviour, i.e. message sent to DropCallBack	//	//	RETURNS:	array["dropCallbackMessage"]	*/		string $returnMsg[1];		// must not return empty array;	$returnMsg[0] = "void";		// MMB = MovePicker	if($mods == 0) {		$returnMsg[0] = "move";		print("// aweCP Move: Drop on upper/lower half of another Picker to insert before/after\n");	}	// MMB+SHIFT = MergePickers	if($mods == 1) {		$returnMsg[0] = "merge";		print("// aweCP Merge: Drop on another Picker and merge\n");	}	// MMB+CTRL = CombinePickers	if($mods == 2) {		$returnMsg[0] = "combine";		print("// aweCP Combine: Drop on another Picker and combine into new\n");	}		return $returnMsg;}global proc aweCPBtnDropCB(string $dragCtrl, string $dropCtrl, string $msg[], int $x, int $y, int $type) {	// global DropCallBack for Picker Buttons		/*	//	The string in $msg causes it to execute a specific function 	//	based on the modifier key pressed	//	//	Currently, the dropCallback is attached to a Picker's Layout (!), not the button itself.	*/		$message = $msg[0];		switch ($message) {		case "merge":			aweCPMergePickers($dragCtrl, $dropCtrl);			break;		case "combine":			aweCPCombinePickers($dragCtrl, $dropCtrl);			break;		case "move":			aweCPMovePicker($dragCtrl, $dropCtrl, $y);			break;	}}